<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Mysql笔记 为什么innodb存储引擎选择b+树来做索引结构 普通二叉树，  层数太高，io次数多 节点（每页）只存一个，io次数多 节点（每页）内的数据存的是此行全部数据，节点存的数据个数少 极端情况链表  二叉平衡树  严格左右子树高度限制，左旋右旋开销大  b树 balance tree多路平衡查找树  节点（每页）存多个数据，两个数据三个指针，也就是三个 度degree（分叉数） 数据">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Mysql笔记 为什么innodb存储引擎选择b+树来做索引结构 普通二叉树，  层数太高，io次数多 节点（每页）只存一个，io次数多 节点（每页）内的数据存的是此行全部数据，节点存的数据个数少 极端情况链表  二叉平衡树  严格左右子树高度限制，左旋右旋开销大  b树 balance tree多路平衡查找树  节点（每页）存多个数据，两个数据三个指针，也就是三个 度degree（分叉数） 数据">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/v2-f275ee89b60272d577cce2c23cae1e75_is.jpg">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/v2-4104da055e29964776018a62bef6b9c6_s.jpg">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/v2-981ea6d2c990f191554da98706eb64b9_400x224.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220522231727392.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220522224705430.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220522224825708.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220522224836391.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220522225614949.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220522231727392.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220522232437864.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220522232554583.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220522233412618.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220523194420562.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220523194433836.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220523194443584.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220523195050686.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220523195146822.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220523195445880.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220523195636046.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220523204352484.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220523204403608.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220523204514626.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220523205356973.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220523210748664.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220523211036858.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/3FB3FAE295A891993D2C2D8D6F04357E.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220523223311687.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220523223327789.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220523223413762.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220523223420102.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220523223547399.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220523223701975.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220523233510552.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220523234000027.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220523234126613.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220523234139059.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/65667BA5E0ACE726B41E4EA9D492E1FF.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/A2899FE3D8508657650A8AEC44FE3AF6.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220524002622737.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220524002714001.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220524002750469.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220524195504309.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220524200102841.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220524200358106.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220524001547402.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220524205527096.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220524210536295.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220524210546114.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220524211155229.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220524211711875.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220524214402649.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220524214430074.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220524214451416.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220524215040250.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220524235507733.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220524235755060.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220524235908496.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220809141619872.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220526144836491.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220526145416134.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220526151613182.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220526152817702.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220526153014534.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220526153034569.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220526153258355.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220526152731986.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220526153901239.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220526160104120.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220526160351511.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220526160814115.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220527211001146.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220527211341254.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220527211403715.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220527211852847.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220527211904545.png">
<meta property="og:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/img/image-20220527211950369.png">
<meta property="article:published_time" content="2022-08-15T03:15:24.546Z">
<meta property="article:modified_time" content="2022-08-09T06:57:52.897Z">
<meta property="article:author" content="0xiceee">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/v2-f275ee89b60272d577cce2c23cae1e75_is.jpg">

<link rel="canonical" href="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title> | Hexo</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?4ebc77cc93c9a8d2365cc0589b5171b1";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/15/Mysql%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="0xiceee">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-15 11:15:24" itemprop="dateCreated datePublished" datetime="2022-08-15T11:15:24+08:00">2022-08-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-09 14:57:52" itemprop="dateModified" datetime="2022-08-09T14:57:52+08:00">2022-08-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Mysql笔记"><a href="#Mysql笔记" class="headerlink" title="Mysql笔记"></a>Mysql笔记</h1><ol>
<li><p>为什么innodb存储引擎选择b+树来做索引结构</p>
<p>普通二叉树，</p>
<ul>
<li>层数太高，io次数多</li>
<li>节点（每页）只存一个，io次数多</li>
<li>节点（每页）内的数据存的是此行全部数据，节点存的数据个数少</li>
<li>极端情况链表</li>
</ul>
<p>二叉平衡树</p>
<ul>
<li>严格左右子树高度限制，左旋右旋开销大</li>
</ul>
<p>b树 balance tree多路平衡查找树</p>
<ul>
<li>节点（每页）存多个数据，两个数据三个指针，也就是三个 度degree（分叉数）</li>
<li>数据下的指针直接指向 磁盘物理存储的位置</li>
<li>页分裂，页合并 保证树的平衡</li>
</ul>
<p>b+树    plus版 b树</p>
<ul>
<li>节点（每页）存多个数据，两个数据两个指针</li>
<li>指针指向子节点（页）</li>
<li>数据都在叶子节点</li>
<li>所有数据地址都存在叶子节点上，所以每次查询次数都相同，比B-树稳定</li>
<li>叶子节点（页）  之间 有指针（InnoDB改成双向指针），查范围更快</li>
</ul>
<blockquote>
<p>相对于二叉树来说（二叉平衡： 由于构造过于严格“不能超过最低一个节点”  在进行增 删节点时难免会导致左旋右旋来操作，增大时间开销，红黑树：红黑树算是二叉树和二叉平衡树  的折中方案  ，都算二叉树），层级更少，搜索效率高</p>
<p>对于b树（二叉树），无论是叶子结点还是非叶子节点都需要保存数据以及数据的索引（指针），而每个节点的存储最终都是在磁盘的  页/块  上的，固定大小16k，而b+，树非叶子节点只存 索引，这样在跟磁盘io操作会效率更高（切换页、块都需要对磁盘io操作）</p>
<p>mysql进行过磁盘读取时，是以页为单位进行读取，每个节点表示一页。而平衡二叉树每个节点存储一个关键词，导致存储空间被浪费，导致需要多次io查找，浪费性能</p>
<p>，而且同样一块存储空间16k，b+存的索引更多，同样的数据量，b树存储需要额外增加高度，降低性能</p>
<p>同样一个16k大小的节点上 存的索引少了，就类似于 像二叉树退化了（极限情况只存一个数据就是二叉树了），二叉树的话层数自然变多，性能自然下降</p>
<ul>
<li>红黑树多用于内部排序，即全放在内存中</li>
<li>B+树多用于外存上时，B+也被成为一个磁盘友好的数据结构</li>
<li>红黑树和平衡二叉树有相同缺点，每个节点存储一个关键词，数据量大时，导致红黑树的深度很深，mysql每次读取时消耗大量io </li>
</ul>
<p>innodb的b+对经典b+做了修改，叶子节点额外添加了索引，相当于双向链表了，便于排序和范围查找</p>
<h2 id="B-树相比B-树的优点"><a href="#B-树相比B-树的优点" class="headerlink" title="B+树相比B-树的优点"></a>B+树相比B-树的优点</h2><ul>
<li>B+树非叶子节点只存储key值，而B-树存储key值和data值，这样B+树每次读取时可以读取到更多的key值</li>
<li>mysql进行区间访问时，由于B+树叶子节点之间用指针相连，只需要遍历所有的叶子节点即可；而B-树则需要中序遍历那样遍历</li>
<li>B+树非叶子节点只存储key值，而B-树存储key值和data值，导致B+树的层级更少，查询效率更高</li>
<li>B+树所有关键词地址都存在叶子节点上，所以每次查询次数都相同，比B-树稳定</li>
</ul>
<p>而不用哈希结构是因为，哈希结构是等值匹配无法排序范围查找</p>
<h2 id="为什么高度为3的B-树存储千万级数据？"><a href="#为什么高度为3的B-树存储千万级数据？" class="headerlink" title="为什么高度为3的B+树存储千万级数据？"></a>为什么高度为3的B+树存储千万级数据？</h2><blockquote>
<p>解释这个问题的前提，mysql使用InnoDB引擎，mysql默认页文件大小为16k</p>
</blockquote>
<p>假设我们一行数据大小为1k，那么一页存储16条数据，也就是说一个叶子节点能存储16条数据</p>
<p>再来看看非叶子节点，假设主键ID为bigint类型，那么长度为8B，指针大小在InnoDB引擎中的大小为6B，一共14B，那么一页中可以存放16k/14B=1170个(主键+指针)</p>
<p>也就是说高度为2的B+树可以存储的数据为:1170<em>16=18720条；高度为3的B+树可以存储的数据为:1170</em>1170*16=21902400(千万条数据)</p>
<p><strong>这也是为什么mysql可以支撑千万级别数据的原因</strong></p>
<p>性能排行：二叉树 红黑树 二叉平衡树 b+</p>
</blockquote>
</li>
</ol>
<p>专栏<a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1328416218731360256">迈莫coding</a></p>
<p>写文章</p>
<p><img src="v2-f275ee89b60272d577cce2c23cae1e75_is.jpg" alt="点击打开iceee的主页"></p>
<p>迈莫coding</p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/people/bestiario-98"><img src="v2-4104da055e29964776018a62bef6b9c6_s.jpg" alt="IT界学习笔记"></a></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/people/bestiario-98">IT界学习笔记</a></p>
<p> · </p>
<p>30 </p>
<p>篇内容</p>
<h2 id="揭开http报文的神秘面纱"><a href="#揭开http报文的神秘面纱" class="headerlink" title="揭开http报文的神秘面纱"></a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/366912538">揭开http报文的神秘面纱</a></h2><p><img src="v2-981ea6d2c990f191554da98706eb64b9_400x224.png" alt="cover"></p>
<p>今天是计网的第二弹，主要叙述http报文的神秘面纱。相信大家在写项目中，或多或少遇到过，进行http访问时，header头部上需要加上Content-Type、Host等等，但有时候为了项目顺利完成，…阅读全文</p>
<h1 id="架构，执行一条sql语句发生了什么"><a href="#架构，执行一条sql语句发生了什么" class="headerlink" title="架构，执行一条sql语句发生了什么"></a>架构，执行一条sql语句发生了什么</h1><p><img src="img/image-20220522231727392.png" alt="image-20220522231727392"></p>
<p>首先查缓存，query_cache默认关闭，后期取消了，因为没有啥用，缓存的是语句对应的结果，多一个空格大小写不对同样结果的语句也无法用缓存，一般用redis代替，缓存结构</p>
<p>解析器</p>
<p>关键字，语法解析，比如有（就得有），括号要成对出现</p>
<p>预处理器</p>
<p>sql语句里的表名是否真的存在，别名使用错误，用户是否有执行此sql的权限（只读权限无法执行update）</p>
<p>优化器</p>
<p>同一条sql语句有多中执行策略，结果都是一致的，优化器判断怎么样执行cost最小，得出一个执行计划</p>
<p>执行器</p>
<p>去执行操作</p>
<h1 id="事务四大特性"><a href="#事务四大特性" class="headerlink" title="事务四大特性"></a>事务四大特性</h1><p>ACID原子性、一致性、隔离性、持久性</p>
<p>A:  atomicity事务操作是最小分割单位</p>
<p>C：consistency事务执行前后数据保持一致状态，即all fail or all success</p>
<p>I：isolation事务不受外界操作影响的隔离环境下运行</p>
<p>D:  durability事务一旦提交or回滚，产生的数据变化是永久的</p>
<h1 id="并发事务三个问题"><a href="#并发事务三个问题" class="headerlink" title="并发事务三个问题"></a>并发事务三个问题</h1><p>脏读：一个事务读到另一个事务还没提交的数据</p>
<p><img src="img/image-20220522224705430.png" alt="image-20220522224705430"></p>
<blockquote>
<p>主要是别的事务来 select的隔离级别</p>
</blockquote>
<p>不可重复读：一个事务先后读取同一条记录，结果不一致</p>
<p><img src="img/image-20220522224825708.png" alt="image-20220522224825708"></p>
<blockquote>
<p>主要是别的事务来 update的隔离级别</p>
</blockquote>
<p>幻读：一个事务按照条件查询不到某行，但是插入时提示此行已经存在</p>
<p><img src="img/image-20220522224836391.png" alt="image-20220522224836391"></p>
<blockquote>
<p>主要是别的事务来 insert的隔离级别,也包括删除delete</p>
</blockquote>
<h1 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h1><table>
<thead>
<tr>
<th align="left">隔离级别</th>
<th align="left">脏读</th>
<th>不可重复度</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="left">read uncommitted</td>
<td align="left">√会发生</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td align="left">read committed（ORACLE默认）</td>
<td align="left">×不会发生</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td align="left">repeatable read（MySQL默认）</td>
<td align="left">×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td align="left">serializable</td>
<td align="left">×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<p><img src="img/image-20220522225614949.png" alt="image-20220522225614949"></p>
<h1 id="存储引擎介绍"><a href="#存储引擎介绍" class="headerlink" title="存储引擎介绍"></a>存储引擎介绍</h1><p><img src="img/image-20220522231727392.png" alt="image-20220522231727392"></p>
<blockquote>
<p>我们也需要在合适的场景选择合适的存储引擎。</p>
<p>存储引擎就是<strong>存储数据、建立索引、更新/查询数据</strong>等技术的实现方式 。</p>
<p>存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型。</p>
<p>我们可以在创建表的时候，来指定选择的存储引擎，如果没有指定将自动选择默认的存储引擎。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table my_myisam( </span><br><span class="line">	id int, </span><br><span class="line">	name varchar(10) </span><br><span class="line">) engine &#x3D; MyISAM ;</span><br></pre></td></tr></table></figure>



<p>DMl：增删改</p>
<h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><p>MySQL5.5后默认的存储引擎</p>
<p>特点：</p>
<ul>
<li>支持事务，遵循ACID</li>
<li>提供行级锁，提高并发访问性能（普通的是表锁，锁的范围粒度太大了）</li>
<li>支持外键约束，保证数据的完整性和正确性</li>
</ul>
<p>存储为xxx.ibd表空间文件，8.0后默认打开innodb_file_per_table每个表对应这样一个表空间文件，里面存的是表结构（frm旧，sdi新）、数据和索引</p>
<blockquote>
<p> sdi存的表结构：有什么字段，每个字段的配置，jason格式存储</p>
</blockquote>
<p><img src="img/image-20220522232437864.png" alt="image-20220522232437864"></p>
<p>InnoDB逻辑存储结构</p>
<p><img src="img/image-20220522232554583.png" alt="image-20220522232554583"></p>
<h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h2><p>MySQL早期默认存储引擎</p>
<p>特点：</p>
<ul>
<li>不支持事务</li>
<li>不支持外键</li>
<li>只支持表锁，不支持行锁</li>
<li>访问速度快</li>
</ul>
<p>存储文件：</p>
<ul>
<li>xxx.sdi：存储表结构，即有什么字段，每个字段的配置，jason格式存储</li>
<li>xxx.MYD：存储数据</li>
<li>xxx.MYI：存储索引</li>
</ul>
<p>因为只支持表锁，只建议在 读为主or只读的数据使用</p>
<h2 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h2><p>Memory引擎的表数据存储在内存中，硬件or断电等问题数据就没了，只能作为临时表使用或缓存使用</p>
<p>特点：</p>
<ul>
<li>内存存放</li>
<li>默认使用hash索引</li>
</ul>
<p>存储文件：</p>
<p>xxx.sdi:Memory只需要存储sdi文件，即表结构</p>
<p>需要考虑的就是 持久性，还有就是内存比较昂贵，数据量大小去要考虑</p>
<p>csv：数据格式简单，适合导入导出换表操作</p>
<p>archive：归档专用引擎，不能更改删除操作，只关注数据的 压缩最小空间保存，用来做历史数据归档保存</p>
<p>区别：</p>
<img src="img/image-20220522233412618.png" alt="image-20220522233412618" style="zoom: 67%;" />

<p><strong>InnoDB</strong>: 是Mysql的默认存储引擎，支持事务、外键。如果应用对事务的完整性有比较高的要</p>
<p>求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操</p>
<p>作，那么InnoDB存储引擎是比较合适的选择。</p>
<p><strong>MyISAM</strong> ： 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完</p>
<p>整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。</p>
<p>应用：日志相关，电商中 足迹，评论  （不在乎并发，非核心数据，可以偶尔丢数据。）</p>
<p>同类型的就是MongoDB</p>
<p><strong>MEMORY</strong>：将所有数据保存在内存中，访问速度快，通常用于<strong>临时表及缓存</strong>。MEMORY的缺陷就是</p>
<p>对表的大小有限制，太大的表无法缓存在内存中，而且<strong>无法保障数据的安全性</strong>。</p>
<p>同类型的就是Redis</p>
<h1 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h1><h2 id="b树"><a href="#b树" class="headerlink" title="b树"></a>b树</h2><p><img src="img/image-20220523194420562.png" alt="image-20220523194420562"></p>
<p><img src="img/image-20220523194433836.png" alt="image-20220523194433836"></p>
<p><img src="img/image-20220523194443584.png" alt="image-20220523194443584"></p>
<p>如果索引使用二叉树，有可能形成链表结构，性能大大降低，而且大数据量下，二叉树层级较深。</p>
<p>红黑树是一种自平衡二叉树，但是大数据量也会层级较深。</p>
<p>B-Tree（多路平衡查找树）</p>
<p><img src="img/image-20220523195050686.png" alt="image-20220523195050686"></p>
<p>B+Tree</p>
<p><img src="img/image-20220523195146822.png" alt="image-20220523195146822"></p>
<p>B+Tree 与 B-Tree相比，主要有以下三点区别：</p>
<ul>
<li><p>所有的数据都会出现在叶子节点。</p>
</li>
<li><p>叶子节点形成一个单向链表。</p>
</li>
<li><p>非叶子节点仅仅起到索引数据作用，具体的数据都是在叶子节点存放的。</p>
</li>
</ul>
<p><img src="img/image-20220523195445880.png" alt="image-20220523195445880"></p>
<h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><p><img src="img/image-20220523195636046.png" alt="image-20220523195636046"></p>
<p>特点：</p>
<p>A. Hash索引只能用于对等比较(=，in)，<strong>不支持范围查询</strong>（between，&gt;，&lt; ，…）</p>
<p>B. <strong>无法利用索引完成排序操作</strong></p>
<p>C. 查询效率高，<strong>通常</strong>(不存在hash冲突的情况)只需要<strong>一次</strong>检索就可以了，效率通常要高于B+tree索 </p>
<p>引</p>
<p> 存储引擎支持：</p>
<p>在MySQL中，支持hash索引的是Memory存储引擎。</p>
<p> 而InnoDB中具有自适应hash功能，hash索引是InnoDB存储引擎根据B+Tree索引在指定条件下自动构建的。</p>
<h1 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h1><p><img src="img/image-20220523204352484.png" alt="image-20220523204352484"></p>
<p><img src="img/image-20220523204403608.png" alt="image-20220523204403608"></p>
<p>聚集索引选取规则:</p>
<p>如果存在主键，<strong>主键索引</strong>就是聚集索引。</p>
<p>如果不存在主键，将使用第一个没有null值的唯一（UNIQUE）索引（小注意，唯一索引设置了不可以插入重复值，但是可以插入多个null）作为聚集索引。</p>
<p>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索</p>
<p>引。</p>
<p><img src="img/image-20220523204514626.png" alt="image-20220523204514626"></p>
<p>所以如果你直接where id = 1，就会币where name = ‘jack’要快，因为id走的聚集索引，直接查到行数据，而name走的二级索引，查到对应name后只有主键id，然后再拿id再来一遍聚集索引查行数据。</p>
<h1 id="SQL性能分析"><a href="#SQL性能分析" class="headerlink" title="SQL性能分析"></a>SQL性能分析</h1><h2 id="SQL执行频率"><a href="#SQL执行频率" class="headerlink" title="SQL执行频率"></a>SQL执行频率</h2><p>MySQL 客户端连接成功后，通过<code> show [session|global] status</code> 命令可以提供服务器状态信</p>
<p>息。通过如下指令，可以查看当前数据库的INSERT、UPDATE、DELETE、SELECT的访问频次：</p>
<p>Com_delete: 删除次数 </p>
<p>CREATE UNIQUE INDEX idx_user_phone ON tb_user(phone); </p>
<p>CREATE INDEX idx_user_pro_age_sta ON tb_user(profession,age,status); </p>
<p>CREATE INDEX idx_email ON tb_user(email); </p>
<p>show index from tb_user; </p>
<p>– session 是查看当前会话 ; </p>
<p>– global 是查询全局数据 ; </p>
<p><code>SHOW GLOBAL STATUS LIKE &#39;Com_______&#39;; </code></p>
<p>上面这条命令就是查询全局数据库增删改查的次数。</p>
<p>Com_delete: 删除次数 </p>
<p>Com_insert: 插入次数</p>
<p>Com_select: 查询次数</p>
<p>Com_update: 更新次数</p>
<p>通过上述指令，我们可以查看到当前数据库到底是以查询为主，还是以增删改为主，从而为数据</p>
<p>库优化提供参考依据。</p>
<p> 如果是以增删改为主，我们可以考虑不对其进行索引的优化。 </p>
<p><strong>如果是以查询为主，那么就要考虑对数据库的索引进行优化了。</strong></p>
<p>接下来，我们就来根据MySQL中的慢查询日志找到<strong>慢查询</strong>SQL进行优化。</p>
<h2 id="慢查询SQL"><a href="#慢查询SQL" class="headerlink" title="慢查询SQL"></a>慢查询SQL</h2><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有</p>
<p>SQL语句的日志。</p>
<p>MySQL的慢查询日志默认没有开启，我们可以查看一下系统变量 <strong>slow_query_log</strong>。</p>
<img src="img/image-20220523205356973.png" alt="image-20220523205356973" style="zoom:200%;" />

<p>如果要开启慢查询日志，需要在MySQL的配置文件（/etc/my.cnf）中配置如下信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 开启MySQL慢日志查询开关 </span><br><span class="line">slow_query_log&#x3D;1 </span><br><span class="line"># 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志 </span><br><span class="line">long_query_time&#x3D;2</span><br></pre></td></tr></table></figure>



<blockquote>
<p>在我们开启了慢 SQL 监控后，如果你发现<strong>「偶尔」会出现一些用时稍长的 SQL</strong>，这可能是因为脏页在刷新到磁盘时可能会给数据库带来性能开销，导致数据库操作<strong>抖动</strong>。</p>
<p>如果间断出现这种现象，就需要调大 Buffer Pool 空间或 redo log 日志的大小。</p>
</blockquote>
<p>这样就可以通过慢查询日志，就可以定位出执行效率比较低的SQL，从而有针对性的进行优化。</p>
<h2 id="profile执行耗时详情"><a href="#profile执行耗时详情" class="headerlink" title="profile执行耗时详情"></a>profile执行耗时详情</h2><p>找到慢SQL后通过profile查看耗时详情</p>
<p><img src="img/image-20220523210748664.png" alt="image-20220523210748664"></p>
<h2 id="explain执行计划"><a href="#explain执行计划" class="headerlink" title="explain执行计划"></a>explain执行计划</h2><p>在SQL前加上explain就可以查看</p>
<p><img src="img/image-20220523211036858.png" alt="image-20220523211036858"></p>
<p>id:</p>
<p><img src="img/3FB3FAE295A891993D2C2D8D6F04357E.png" alt="img"></p>
<p>表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION 中的第二个或者后面的查询语句）、SUBQUERY（SELECT/WHERE之后包含了子查询）等</p>
<p>表示连接类型，性能由好到差的连接类型为NULL、system、const、eq_ref、ref、range、 index、all 。</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>select查询的序列号，表示查询中执行select子句或者是操作表的顺序(id相同，执行顺序从上到下；id不同，值越大，越先执行)。</td>
</tr>
<tr>
<td>select_type</td>
<td>表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION 中的第二个或者后面的查询语句）、SUBQUERY（SELECT/WHERE之后包含了子查询）等。</td>
</tr>
<tr>
<td>type</td>
<td>表示连接类型，性能由好到差的连接类型为NULL、system、const、eq_ref、ref、range、 index、all 。</td>
</tr>
<tr>
<td>posible_key</td>
<td>显示可能应用在这张表上的索引，一个或多个。</td>
</tr>
<tr>
<td>key</td>
<td>实际使用的索引，如果为NULL，则没有使用索引。</td>
</tr>
<tr>
<td>key_len</td>
<td>表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下， 长度越短越好 。</td>
</tr>
<tr>
<td>rows</td>
<td>MySQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值，可能并不总是准确的。</td>
</tr>
<tr>
<td>filtered</td>
<td>表示返回结果的行数占需读取行数的百分比， filtered 的值越大越好。</td>
</tr>
</tbody></table>
<h1 id="索引的使用原则"><a href="#索引的使用原则" class="headerlink" title="索引的使用原则"></a>索引的使用原则</h1><h2 id="最左前缀法则"><a href="#最左前缀法则" class="headerlink" title="最左前缀法则"></a>最左前缀法则</h2><p>如果索引了多列（<strong>联合索引</strong>），要遵守最左前缀法则。</p>
<p>最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，索引将会部分失效(后面的字段索引失效)。 </p>
<p>在 tb_user 表中，有一个联合索引，这个联合索引涉及到三个字段，顺序分别为：profession，age，status。</p>
<p>对于最左前缀法则指的是，查询时，最左边的列必须存在，否则索引全部失效。</p>
<p>而且中间不能跳过某一列，否则该列后面的字段索引将失效。 </p>
<p>最左前缀法则中指的最左边的列，是指在查询时，联合索引的最左边的字段(即是第一个字段)必须存在，<strong>与我们编写SQL时，条件编写的先后顺序无关。</strong></p>
<h2 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h2><p>联合索引中，出现范围查询(&gt;,&lt;)，范围查询右侧的列索引失效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from tb_user where profession &#x3D; &#39;软件工程&#39; and age &gt; 30 and status &#x3D; &#39;0&#39;;</span><br></pre></td></tr></table></figure>

<p>当范围查询使用&gt; 或 &lt; 时，走联合索引了，但是范围查询右边的status字段是没有走索引的。</p>
<p>所以，在业务允许的情况下，**尽可能的使用类似于 &gt;= 或 &lt;= 这类的范围查询，**而避免使用 &gt; 或 &lt; 。 </p>
<h2 id="索引列运算"><a href="#索引列运算" class="headerlink" title="索引列运算"></a>索引列运算</h2><p>不要在索引列上进行运算操作， 索引将失效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from tb_user where substring(phone,10,2) &#x3D; &#39;15&#39;;</span><br></pre></td></tr></table></figure>

<p>上面的SQL索引失效，explain后key为null</p>
<h2 id="字符串不加引号"><a href="#字符串不加引号" class="headerlink" title="字符串不加引号"></a>字符串不加引号</h2><p>字符串类型字段使用时，不加引号，索引将失效。</p>
<p><img src="img/image-20220523223311687.png" alt="image-20220523223311687"></p>
<p><img src="img/image-20220523223327789.png" alt="image-20220523223327789"></p>
<p>经过上面两组示例，我们会明显的发现，如果字符串不加单引号，对于查询结果，没什么影响，但是数</p>
<p>据库存在隐式类型转换，索引将失效。</p>
<h2 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h2><p>如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。</p>
<p><img src="img/image-20220523223413762.png" alt="image-20220523223413762"></p>
<p><img src="img/image-20220523223420102.png" alt="image-20220523223420102"></p>
<h2 id="or连接条件"><a href="#or连接条件" class="headerlink" title="or连接条件"></a>or连接条件</h2><p>用or分割开的条件， 如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会</p>
<p>被用到。</p>
<p><img src="img/image-20220523223547399.png" alt="image-20220523223547399"></p>
<p>最终，我们发现，当or连接的条件，<strong>左右两侧字段都有索引时，索引才会生效</strong>。</p>
<h2 id="数据分布影响"><a href="#数据分布影响" class="headerlink" title="数据分布影响"></a>数据分布影响</h2><p>如果MySQL评估使用索引比全表更慢，则不使用索引。</p>
<p><img src="img/image-20220523223701975.png" alt="image-20220523223701975"></p>
<p>经过测试我们发现，相同的SQL语句，只是传入的字段值不同，最终的执行计划也完全不一样，这是为</p>
<p>什么呢？</p>
<p>就是因为MySQL在查询时，会评估使用索引的效率与走全表扫描的效率，如果走全表扫描更快，则放弃</p>
<p>索引，走全表扫描。 因为索引是用来索引少量数据的，如果通过索引查询返回大批量的数据，则还不</p>
<p>如走全表扫描来的快，此时索引就会失效。</p>
<p>查询时MySQL会评估，走索引快，还是全表扫描快，如果全表扫描更快，则放弃索引走全表扫描。 因此，is null 、is not null是否走索引，得具体情况具体分析，并不是固定的，<strong>如果此表极个别为null，则is null走索引；如果大部分都是null，那就不走索引。</strong></p>
<p>其实对应的就是数据的 分散集中程度，性别字段就不适合加索引，太集中了就两种，手机号就比较适合加，唯一的字段适合加索引。</p>
<h2 id="SQL提示"><a href="#SQL提示" class="headerlink" title="SQL提示"></a>SQL提示</h2><p><img src="img/image-20220523233510552.png" alt="image-20220523233510552"></p>
<h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>extra：using index代表使用了覆盖索引</p>
<p>尽量使用覆盖索引，减少select *。 那么什么是覆盖索引呢？ 覆盖索引是指 查询使用了索引，并</p>
<p>且需要返回的列，在该索引中已经全部能够找到 。 </p>
<p>实例：</p>
<p>一张表, 有四个字段(id, username, password, status), 由于数据量大, 需要对</p>
<p>以下SQL语句进行优化, 该如何进行才是最优方案:</p>
<p>select id,username,password from tb_user where username =’itcast’;</p>
<p>答案: 针对于 username, password建立联合索引, </p>
<p>sql为: create index idx_user_name_pass on tb_user(username,password);</p>
<p>这样可以避免上述的SQL语句，在查询的过程中，出现回表查询。</p>
<p><strong>因为有联合索引了，查到对应username的页表（page）上就带有id 和 password，省的再去拿id去聚集索引回表查password。</strong></p>
<h2 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h2><p>当字段类型为字符串（varchar，text，longtext等）时，有时候需要索引很长的字符串，这会让</p>
<p>索引变得很大，查询时，浪费大量的磁盘IO， 影响查询效率。此时可以只将字符串的一部分前缀，建</p>
<p>立索引，这样可以大大节约索引空间，从而提高索引效率。</p>
<p><img src="img/image-20220523234000027.png" alt="image-20220523234000027"></p>
<p>前缀的长度越能保证id唯一越好。就是分散程度越大越好。</p>
<h2 id="单列索引与联合索引"><a href="#单列索引与联合索引" class="headerlink" title="单列索引与联合索引"></a>单列索引与联合索引</h2><p>单列索引：即一个索引只包含单个列。</p>
<p>联合索引：即一个索引包含了多个列。</p>
<p><img src="img/image-20220523234126613.png" alt="image-20220523234126613"></p>
<p><img src="img/image-20220523234139059.png" alt="image-20220523234139059"></p>
<h1 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h1><p>1). 针对于数据量较大，且查询比较<strong>频繁</strong>的表建立索引。</p>
<p>2). 针对于常作为<strong>查询条件</strong>（where）、排序（order by）、分组（group by）操作的字段建立索引。</p>
<p>3). 尽量选择<strong>区分度高的列</strong>作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</p>
<p>4). 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立<strong>前缀索引</strong>。</p>
<p>5). 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以<strong>覆盖索引</strong>，节省存储空间，避免回表，提高查询效率。</p>
<p>6). 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响<strong>增删改的效率</strong>。</p>
<p>7). 如果索引列不能存储NULL值，请在创建表时使用NOT NULL<strong>约束</strong>它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。</p>
<h1 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h1><h2 id="insert插入数据"><a href="#insert插入数据" class="headerlink" title="insert插入数据"></a>insert插入数据</h2><p><img src="img/65667BA5E0ACE726B41E4EA9D492E1FF.png" alt="img"></p>
<p>默认自动提交事务，一个一个插入频繁开启，提交事务浪费大量性能。</p>
<p>按照主键顺序，方便生成索引。主键顺序插入性能高于乱序插入。</p>
<p>如果是数百万量级数据，使用load加载。</p>
<p><img src="img/A2899FE3D8508657650A8AEC44FE3AF6.png" alt="img"></p>
<h2 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h2><p>主键顺序插入性能高于乱序插入，为什么呢？</p>
<p><img src="img/image-20220524002622737.png" alt="image-20220524002622737"></p>
<p><img src="img/image-20220524002714001.png" alt="image-20220524002714001"></p>
<p><img src="img/image-20220524002750469.png" alt="image-20220524002750469"></p>
<p>总而言之，就是b+数下面的叶子节点维护的类似于一个链表吧，每个node是个页，存储数据的页，而且这个链表的顺序是按照主键的顺序排列的。</p>
<p>所以，如果你按照主键顺序插入，使用自增主键，就是按着往后写，如果乱序可能会造成在完成一大半元素插入后插入一个主键靠前的数据，导致此页容量不够存，就会所有后面的元素后移，也就是所说的页分裂。</p>
<p><strong>所以，按照主键顺序插入可以减少页分裂开销，提升性能。</strong></p>
<p>同样，为了减少页分裂，要么让页大一点，要么让一页里面多存一点，页大小是硬件无法改变，我们可以让主键长度小一点，一个页内可以存放更多的数据。<strong>这样二级索引下面每个叶子节点挂的主键就能每个页多挂一点，减少空间占用。</strong></p>
<p><strong>所以尽量不要用uuid或身份证号，因为他们无序且长度过长。</strong></p>
<h2 id="order-by优化"><a href="#order-by优化" class="headerlink" title="order by优化"></a>order by优化</h2><p>MySQL的排序，有两种方式：</p>
<p>Using filesort : 通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sortbuffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。</p>
<p>Using index : 通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高。</p>
<p>对于以上的两种排序方式，Using index的性能高，而Using filesort的性能低，我们在优化排序</p>
<p>操作时，尽量要优化为 Using index。</p>
<p>A. 根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。</p>
<p>B. 尽量使用覆盖索引。</p>
<p>C. 多字段排序, 一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）。</p>
<p>D. 如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小sort_buffer_size(默认256k)。 </p>
<h2 id="group-by优化"><a href="#group-by优化" class="headerlink" title="group by优化"></a>group by优化</h2><p>A. 在分组操作时，可以通过索引来提高效率。</p>
<p>B. 分组操作时，索引的使用也是满足最左前缀法则的。</p>
<h2 id="limit优化"><a href="#limit优化" class="headerlink" title="limit优化"></a>limit优化</h2><p>在数据量比较大时，如果进行limit分页查询，在查询时，越往后，分页查询效率越低。</p>
<p><img src="img/image-20220524195504309.png" alt="image-20220524195504309"></p>
<p>因为，当在进行分页查询时，如果执行 limit 2000000,10 ，此时需要MySQL排序前2000010 记录，仅仅返回 2000000 - 2000010 的记录，其他记录丢弃，查询排序的代价非常大 。</p>
<p><img src="img/image-20220524200102841.png" alt="image-20220524200102841"></p>
<blockquote>
<p>把子查询当做一个表a，连表查询</p>
</blockquote>
<h2 id="count优化"><a href="#count优化" class="headerlink" title="count优化"></a>count优化</h2><p>如果数据量很大，在执行count操作时，是非常耗时的。</p>
<p>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这数，效率很高； 但是如果是带条件的count，MyISAM也慢。</p>
<p>InnoDB 引擎就麻烦了，它执行 count(*) 的时候，需要把数据一行一行地从引擎里面读来，然后累积计数。</p>
<p>如果说要大幅度提升InnoDB表的count效率，主要的优化思路：自己计数(可以借助于redis这样的数</p>
<p>据库进行,但是如果是带条件的count又比较麻烦了)。 </p>
<blockquote>
<p>count() 是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是NULL，累计值就加 1，否则不加，最后返回累计值。</p>
<p>用法：count（*）、count（主键）、count（字段）、count（数字）</p>
<p><img src="img/image-20220524200358106.png" alt="image-20220524200358106"></p>
</blockquote>
<h2 id="update优化"><a href="#update优化" class="headerlink" title="update优化"></a>update优化</h2><p>InnoDB的行锁是针对索引加的锁，不是针对记录加的锁 ,并且该索引不能失效，否则会从行锁升级为表锁 。</p>
<p>所以你updat where id = 1，就只锁id=1一行，你要是where name = ‘java’,而且你name字段没有索引，那就锁整个表，导致其他来这个表处理业务的线程阻塞，等你释放锁，导致性能下降。</p>
<p>所以，<strong>update更新数据时要根据有索引的字段进行更新。</strong></p>
<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a><strong>视图</strong></h1><p>视图（View）是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视</p>
<p>图的查询中使用的表，并且是在使用视图时动态生成的。</p>
<p>通俗的讲，视图只保存了查询的SQL逻辑，不保存查询结果。所以我们在创建视图的时候，主要的工作</p>
<p>就落在创建这条SQL查询语句上。</p>
<h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a><strong>存储过程</strong></h1><p>存储过程是事先经过编译并存储在数据库中的一段 SQL 语句的集合，调用存储过程可以简化应用开发</p>
<p>人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。</p>
<p>存储过程思想上很简单，就是数据库 SQL 语言层面的代码封装与重用。</p>
<p>特点: </p>
<ul>
<li><p>封装，复用 ———————–&gt; 可以把某一业务SQL封装在存储过程中，需要用到的时候直接调用即可。</p>
</li>
<li><p>可以接收参数，也可以返回数据 ——–&gt; 再存储过程中，可以传递参数，也可以接收返回值。</p>
</li>
<li><p>减少网络交互，效率提升 ————-&gt; 如果涉及到多条SQL，每执行一次都是一次网络传输。 而如果封装在存储过程中，我们只需要网络交互一次可能就可以了。</p>
</li>
</ul>
<h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a><strong>触发器</strong></h1><p>触发器是与表有关的数据库对象，指在insert/update/delete之前(BEFORE)或之后(AFTER)，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性, 日志记录 , 数据校验等操作。使用别名OLD和NEW来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。</p>
<p><img src="img/image-20220524001547402.png" alt="image-20220524001547402"></p>
<blockquote>
<p>DQL   data query  languauge ，数据查询语言：select系列</p>
<p>DDL  data definition language, 数据定义语言 ：对数据库对象（表，视图，存储过程，触发器，索引）的增，删，改</p>
<p>DML  data mainpulation language，数据操纵语言：对数据的 增，删，改</p>
<p>DCL   data control languauge ，数据权限控制语言</p>
</blockquote>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><p>全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。</p>
<p>其典型的使用场景是做<strong>全库的逻辑备份</strong>，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。</p>
<p><img src="img/image-20220524205527096.png" alt="image-20220524205527096"></p>
<p>数据库中加全局锁，是一个比较重的操作，存在以下问题：</p>
<ul>
<li><p>如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。</p>
</li>
<li><p>如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟。</p>
</li>
</ul>
<p>在InnoDB引擎中，我们可以在备份时加上参数 <code>--single-transaction 参</code>数来完成不加锁的一致性数据备份。</p>
<p><code>mysqldump --single-transaction -uroot –p123456 itcast &gt; itcast.sql </code></p>
<p>底层通过 快照读 实现。</p>
<h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><p>表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中。</p>
<p>对于表级锁，主要分为以下三类：</p>
<ul>
<li><p>表锁</p>
</li>
<li><p>元数据锁（meta data lock，MDL）</p>
</li>
<li><p>意向锁</p>
</li>
</ul>
<h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><p>表锁分为两类：</p>
<ol>
<li>表共享读锁（read lock）</li>
<li>表独占写锁（write lock）</li>
</ol>
<p>语法：</p>
<p>加锁：lock tables 表名… read/write。</p>
<p>释放锁：unlock tables / 客户端断开连接 。</p>
<p>读锁特点：客户端a对表加了读锁，所有客户端都可以读此表，所有客户端都不能进行写操作。</p>
<p><img src="img/image-20220524210536295.png" alt="image-20220524210536295"></p>
<p>写锁特点：客户端a对表加了写锁，只有客户端a都可以读、写此表，其他客户端都不能进行读、写操作。</p>
<p><img src="img/image-20220524210546114.png" alt="image-20220524210546114"></p>
<h3 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h3><p>meta data lock , 元数据锁，简写MDL。</p>
<p>MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。为了避免DML与DDL冲突，保证读写的正确性。</p>
<p>这里的元数据，大家可以简单理解为就是一张表的表结构。 </p>
<p>也就是说，某一张表涉及到未提交的事务时，是不能够修改这张表的表结构的。</p>
<p>在MySQL5.5中引入了MDL，当对一张表进行增删改查的时候，加MDL读锁(共享)；</p>
<p>当对表结构进行变更操作的时候，加MDL写锁(排他)。</p>
<p>常见的SQL操作时，所添加的元数据锁：</p>
<p><img src="img/image-20220524211155229.png" alt="image-20220524211155229">也就是说执行蓝框里的sql会加对应的元数据锁，这个锁锁的是表结构，所有蓝框那些增删查改所加的元数据锁都是兼容的，但是执行红框里的修改表结构alter语句时加的EXCLUSIVE锁会与其他元数据锁互斥，也就是说如果别的客户端或事务在执行蓝框的语句还没提交，你这时候是无法执行红框alter语句去修改表结构的。</p>
<p>这个不难理解，别人在用表，你肯定不能把表结构改了啊。（比如别人正在查分数，你把分数字段删了，或者增加一个新的评级字段这样肯定是不行的。）</p>
<p><img src="img/image-20220524211711875.png" alt="image-20220524211711875"></p>
<h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。</p>
<p>作为一个标志，快速判断此表是否有行锁。</p>
<p><img src="img/image-20220524214402649.png" alt="image-20220524214402649"></p>
<p><img src="img/image-20220524214430074.png" alt="image-20220524214430074"></p>
<p><img src="img/image-20220524214451416.png" alt="image-20220524214451416"></p>
<p>总而言之，就是你update某一行，会给这一行加行锁，并且也会对<strong>此行所在表</strong>加一个意向锁，这样别的客户端来对这个表加表锁就不用逐一查看每一行是否有行锁了，直接查看此表是否被加<strong>互斥的意向锁</strong>。</p>
<p>意向锁有两种：</p>
<ul>
<li><p>意向共享锁(IS): 由语句select … lock in share mode添加 。 与 表锁共享锁(read)兼容，与表锁排他锁(write)互斥。</p>
</li>
<li><p>意向排他锁(IX): 由insert、update、delete、select…for update添加 。与表锁共享锁(read)及排他锁(write)都互斥，意向锁之间不会互斥。</p>
</li>
</ul>
<p>一旦事务提交了，意向共享锁、意向排他锁，都会自动释放。</p>
<p>可以通过以下SQL，查看意向锁及行锁的加锁情况：</p>
<p><code>select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks; </code></p>
<h2 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h2><p>行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中。</p>
<p>InnoDB的数据是基于索引组织的，<strong>行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。</strong></p>
<p>对于行级锁，主要分为以下三类：</p>
<p><img src="img/image-20220524215040250.png" alt="image-20220524215040250"></p>
<p><img src="img/image-20220524235507733.png" alt="image-20220524235507733"></p>
<p>行锁，间隙锁，临键锁</p>
<h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><p>行锁又分为：</p>
<ul>
<li><p>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁，但是共享锁可以。</p>
</li>
<li><p>排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。</p>
</li>
</ul>
<p><img src="img/image-20220524235755060.png" alt="image-20220524235755060"></p>
<p>也就是说客户端a加了共享锁，客户端b只能加共享锁，不能加排他锁。</p>
<p>如果客户端a加了排他锁，客户端b什么都不能加。</p>
<p><img src="img/image-20220524235908496.png" alt="image-20220524235908496"></p>
<p>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 <strong>next-key 锁</strong>进行搜索和索引扫描，以防止幻读。</p>
<ul>
<li><p><strong>针对唯一索引进行检索时，对已存在的记录进行等值匹配时</strong>，将会自动优化为行锁。</p>
</li>
<li><p>InnoDB的行锁是<strong>针对于索引加的锁</strong>，<strong>不通过索引条件检索数据</strong>，那么InnoDB将对表中的所有记录加锁，此时 就会升级为表锁。（<strong>因为你没有索引没法加行锁，又要保证安全，只能上表锁</strong>）</p>
</li>
</ul>
<blockquote>
<p>在客户端一中，开启事务，并执行update语句，更新name为Lily的数据，也就是id为19的记录 。</p>
<p>然后在客户端二中更新id为3的记录，却不能直接执行，会处于阻塞状态，为什么呢？</p>
<p>原因就是因为此时，客户端一，根据name字段进行更新时，name字段是没有索引的，如果没有索引，</p>
<p>此时行锁会升级为表锁(因为行锁是对索引项加的锁，而name没有索引)。</p>
<p>接下来，我们再针对name字段建立索引，索引建立之后，再次做一个测试：</p>
<p>此时我们可以看到，客户端一，开启事务，然后依然是根据name进行更新。而客户端二，在更新id为3</p>
<p>的数据时，更新成功，并未进入阻塞状态。 这样就说明，我们根据索引字段进行更新操作，就可以<strong>避</strong></p>
<p><strong>免行锁升级为表锁</strong>的情况。</p>
</blockquote>
<h3 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h3><p>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 临键锁进行搜索和索引扫描，以防止幻读。</p>
<ul>
<li>索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁 。</li>
</ul>
<blockquote>
<p>唯一索引id，1,2,5,8,10。</p>
<p>你去查询 where id = 6；他就会给1-8之间加间隙锁。</p>
<p>防止你再插入id=6导致幻读</p>
</blockquote>
<ul>
<li>索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，间隙锁退化为next-key lock 。</li>
</ul>
<blockquote>
<p>非唯一索引id，1,2,4,6,6,10.</p>
<p>你去查询where id =6；就会给1-10加间隙锁。</p>
<p>防止你再删除id=6导致幻读</p>
</blockquote>
<p>间隙锁唯一目的就是防止其他事物插入间隙。间隙锁可以共存，一个事物在一个间隙上采用间隙锁不会影响另外一个事务在同样地方采用间隙锁。</p>
<h3 id="临键锁"><a href="#临键锁" class="headerlink" title="临键锁"></a>临键锁</h3><ul>
<li>索引上的范围查询(唯一索引)–会访问到不满足条件的第一个值为止。</li>
</ul>
<blockquote>
<p>唯一索引id，1,2,5,15,18,19,25,30</p>
<p>查询的条件为id&gt;=19，并添加共享锁。 此时我们可以根据数据库表中现有的数据，将数据分为三个部</p>
<p>分：</p>
<p>[19]</p>
<p>(19,25]</p>
<p>(25,+∞]</p>
<p>所以数据库数据在加锁是，就是将19加了行锁，25的临键锁（包含25及25之前的间隙），正无穷的临</p>
<p>键锁(正无穷及之前的间隙)。</p>
</blockquote>
<p>不难理解，如果你不给正无穷加临键锁，那你后面可能继续继续insert &gt;= 19的数据，导致查询不一致，幻读</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>首先要明确几个概念：</p>
<p>行级锁加锁规则比较复杂，不同的场景，加锁的形式还不同。</p>
<p>记录的意思就是你用navicat看到的一行数据，一行就是一个记录。</p>
<p>行锁，记录锁，Record Lock</p>
<p>间隙锁，Gap Lock</p>
<p>临键锁，next-key-lock</p>
<p>对记录加锁时，加锁的基本单位是 next-key lock，也就是所谓的临键锁，它是由记录锁和间隙锁组合而成的，next-key lock 是前开后闭区间，而间隙锁是前开后开区间。</p>
<p>但是，next-key lock 在一些场景下会退化成记录锁或间隙锁。</p>
<p>也就是说 只要加行级锁，先加 临键锁，然后根据情况 退化为 记录or间隙锁。</p>
<p>下面举例验证一下</p>
<p><img src="img/image-20220809141619872.png" alt="image-20220809141619872"></p>
<p>上面这个表，id是主键，自带聚集索引，a是普通的列，b是普通的列，但是创建了非唯一索引</p>
<p>主要分为四个维度去分析：</p>
<ul>
<li>唯一索引，等值查询</li>
<li>唯一索引，范围查询</li>
<li>非唯一索引，等值查询</li>
<li>非唯一索引，范围查询</li>
</ul>
<p>还有是否查的到数据加锁规则也不一样，接下来细说</p>
<p>id：0, 4, 8, 16, 32</p>
<p><strong>唯一索引，等值查询</strong></p>
<p>先说结论：</p>
<ul>
<li>当查询的记录是<strong>存在</strong>的，先加 next-key lock，next-key lock 会退化成<strong>「记录锁」</strong>。</li>
<li>当查询的记录是<strong>不存在</strong>的，先加 next-key lock，next-key lock 会退化成<strong>「间隙锁」</strong>。</li>
</ul>
<p>所以当一个事务select where id = 16 for update时，先上临键锁，左开右闭，（8,16] ，但是由于数据存在，所以退化为记录锁，只会锁16这一行记录。这个时候别的事务来update id =16会被阻塞</p>
<p>而当一个事务select where id = 10 for update时，先上临键锁，左开右闭，(8,16]，但是由于数据不存在退化为间隙锁，左右都开，（8,16），锁区间。这个时候别的事务去updat where id = 16可以执行，但是insert id = 15会被阻塞。</p>
<p>id：0, 4, 8, 16, 32</p>
<p><strong>唯一索引，范围查询</strong></p>
<p>select  where id=8 for update;  只加记录锁。<br>select  where id&gt;=8 and id&lt;9 for update;  加锁[8，16）。</p>
<p>最开始要找的第一行是 id = 8，因此 next-key lock(4,8]，但是由于 id 是唯一索引，且该记录是存在的，因此会退化成记录锁，也就是只会对 id = 8 这一行加锁；<br>由于是范围查找，就会继续往后找存在的记录，也就是会找到8后面的数据 id = 16 来进行判断，因为16&gt;9所以会在这一行停下来，然后加 next-key lock (8, 16]，（这里加深理解一下InnoDB加锁基本单位是临键锁，不只要加行锁先上临键锁，然后根据情况退化）然后还是因为你查的是8到9，这边远超了，秉着往最小锁区间发展，这里会退化成间隙锁，加锁范围变为 (8, 16)。<br>所以，此事务执行这个sql后主键索引的锁是记录锁 id=8 和间隙锁(8, 16)。</p>
<p>b：0, 4, 8, 16, 32</p>
<p><strong>非唯一索引，等值查询</strong></p>
<ul>
<li>当查询的记录存在时，除了会加 next-key lock 外，还额外加间隙锁，也就是会加两把锁。</li>
<li>当查询的记录不存在时，只会加 next-key lock，然后会退化为间隙锁，也就是只会加一把锁。</li>
</ul>
<p>比如你select where b = 8 for update；</p>
<ol>
<li>先会对普通索引 b 加上 next-key lock，范围是(4,8];</li>
<li>然后因为是非唯一索引，且查询的记录是存在的，所以还会加上间隙锁，规则是向下遍历到第一个不符合条件的值才能停止，因此间隙锁的范围是(8,16)。</li>
</ol>
<p>所以最终加锁范围就是，（4,16）。</p>
<p>记住，<strong>非唯一索引，等值查询</strong>能查到的情况下 加两把锁，一把临键一把间隙，最终相当于一个大间隙锁。</p>
<p>比如你select where b = 5 for update；</p>
<p>这时数据不存在，就只加一把锁，临键锁（4,8]，并退化为（4,8）间隙锁。</p>
<p><strong>非唯一索引，范围查询</strong></p>
<p>select  where b&gt;=8 and b&lt;9 for update;</p>
<p>跟上面唯一索引大致一样，唯一区别是不会退化为间隙锁，也就是先加next-key lock(4,8]，再加next-key lock(8,16]。</p>
<p>唯一索引等值查询：</p>
<p>当查询的记录是存在的，next-key lock 会退化成「记录锁」。<br>当查询的记录是不存在的，next-key lock 会退化成「间隙锁」。</p>
<p>非唯一索引等值查询：</p>
<p>当查询的记录存在时，除了会加 next-key lock 外，还额外再加一把next-key lock锁，也就是会加两把锁，而且第二把next-key lock会退化为间隙锁，最后组成一个大间隙锁。<br>当查询的记录不存在时，只会加 next-key lock，然后会退化为间隙锁，也就是只会加一把锁，锁住你查询那个不存在的数据两边的间隙。</p>
<p>非唯一索引和主键索引的范围查询的加锁规则不同之处在于：</p>
<p>唯一索引在满足一些条件的时候，next-key lock 退化为间隙锁和记录锁。<br>非唯一索引范围查询，next-key lock 不会退化为间隙锁和记录锁。</p>
<p>这就是rr级别下，<strong>当前读</strong>（也就是 select for update）如何 解决了幻读。通过加锁解决。这都属于悲观锁。</p>
<p>而非for update查询可以通过mvcc实现的乐观锁用可见性算法解决   <strong>快照读</strong> 下  的 幻读问题。</p>
<blockquote>
<p>加锁具体案例看上面的，这里不写了。理解一下，就是保证安全的最小范围锁住</p>
</blockquote>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>事务 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p>
<h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><table>
<thead>
<tr>
<th align="left">隔离级别</th>
<th align="left">脏读</th>
<th>不可重复度</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="left">read uncommitted</td>
<td align="left">√会发生</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td align="left">read committed（ORACLE默认）</td>
<td align="left">×不会发生</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td align="left">repeatable read（MySQL默认）</td>
<td align="left">×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td align="left">serializable</td>
<td align="left">×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<p>脏读：同一个事务内，第二次相同查询读到 别的 事务 <strong>执行</strong>过的的 update、delete</p>
<p>不可重复读：同一个事务内，第二次相同查询读到 别的 事务 <strong>commit</strong>的 update、delete</p>
<p>幻读：同一个事务内，第二次相同查询读到 别的 事务 <strong>commit</strong>的insert语句</p>
<p>事务四大特性：</p>
<p>ACID，不多说了</p>
<p>研究事务原理就是研究InnoDB是如何保证这四大特性的。</p>
<p><img src="img/image-20220526144836491.png" alt="image-20220526144836491"></p>
<h2 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h2><blockquote>
<p>我们知道，在InnoDB引擎中的内存结构中，主要的内存区域就是缓冲池，在缓冲池中缓存了很多的数</p>
<p>据页。 当我们在一个事务中，执行多个增删改的操作时，InnoDB引擎会先操作缓冲池中的数据，如果</p>
<p>缓冲区没有对应的数据，会通过后台线程将磁盘中的数据加载出来，存放在缓冲区中，然后将缓冲池中</p>
<p>的数据修改，修改后的数据页我们称为脏页。 而脏页则会在一定的时机，通过后台线程刷新到磁盘</p>
<p>中，从而保证缓冲区与磁盘的数据一致。 而缓冲区的脏页数据并不是实时刷新的，而是一段时间之后</p>
<p>将缓冲区的数据刷新到磁盘中，假如刷新到磁盘的过程出错了，而提示给用户事务提交成功，而数据却</p>
<p>没有持久化下来，这就出现问题了，没有保证事务的持久性。</p>
</blockquote>
<p><img src="img/image-20220526145416134.png" alt="image-20220526145416134"></p>
<p>为什么不先5再4呢？</p>
<p>（那为什么每一次提交事务，要刷新redo log 到磁盘，而不是直接将buffer pool中的脏页数据刷新到磁盘呢 ?）</p>
<p>因为在业务操作中，我们操作数据一般都是<strong>随机读写磁盘</strong>的，而不是顺序读写磁盘。 而redo log在往磁盘文件中写入数据，由于是<strong>日志文件，所以都是顺序写</strong>的。<strong>顺序写的效率，要远大于随机写。</strong> 这种先写日志的方式，称之为 <strong>WAL</strong>（Write-Ahead Logging）。</p>
<p>磁盘的交互，io非常慢，乱序io更慢，日志是追加的顺序io更快。</p>
<h2 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h2><p>回滚日志，用于记录数据被修改前的信息 , 两个作用 : 提供回滚(保证事务的原子性) 和MVCC(多版本并发控制) 。</p>
<p>undo log和redo log记录物理日志（字段实际数据信息）不一样，它是逻辑日志（sql语句）。</p>
<p>可以认为当delete一条记录时，undolog中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。</p>
<p>Undo log销毁：undo log在事务执行时产生，事务提交时，并不会立即删除undo log，因为这些日志可能还用于MVCC。</p>
<p>Undo log存储：undo log采用<strong>段</strong>的方式进行管理和记录，存放在前面介绍的 <strong>rollback segment回滚段</strong>中，内部包含1024个undo log segment。 </p>
<h2 id="bin-log"><a href="#bin-log" class="headerlink" title="bin log"></a>bin log</h2><p>存在于service层，可以被各种引擎用，上面的两个日志是InnoDB独有的</p>
<p>也是逻辑日志，记录ddl和dml语句的</p>
<p>两个作用：</p>
<ol>
<li>主从同步</li>
<li>数据恢复</li>
</ol>
<p>主机 有个log dump thread生成，发送bin log给从机，从机有一个io thread接收并那容重写进一个relay log，然后sql thread吧日志重放，就同步了</p>
<p><strong>bin log和redo log区别</strong></p>
<p>bin log记录逻辑日志，也就是sql。redo log记录物理日志，也就是数据。</p>
<p>redo log有大小限制，环状，写完就覆盖了，所以只能作用 于 崩溃恢复，数据库崩溃了，马上重启了用这redolog恢复。</p>
<p>binlog 追加写入，无大小限制，比如有人删库跑路了，你可以把上次全量备份数据导入，并找到上次全量备份后开始的bin log 删去最后一条drop 所有表的sql，然后重放一遍就恢复数据了。当然，太大也没法重放</p>
<h2 id="mvcc"><a href="#mvcc" class="headerlink" title="mvcc"></a>mvcc</h2><p>全称 Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。</p>
<blockquote>
<p><strong>多版本并发控制</strong>: 指的是一种提高并发的技术。</p>
<p>最早的数据库系统，<strong>只有读读之间可以并发，读写，写读，写写都要阻塞</strong>。</p>
<p>引入多版本之后，<strong>只有写写之间相互阻塞，其他三种操作都可以并行</strong>，这样大幅度提高了InnoDB的并发度。</p>
<p>在内部实现中，与Postgres在数据行上实现多版本不同，InnoDB是在undolog中实现的，通过undolog可以找回数据的历史版本。找回的数据历史版本可以提供给用户读(按照隔离级别的定义，有些读请求只能看到比较老的数据版本)，也可以在回滚的时候覆盖数据页上的数据。</p>
<p>在InnoDB内部中，会记录一个全局的活跃读写事务数组（read view），其主要用来判断事务的可见性。</p>
</blockquote>
<blockquote>
<p>&lt;高性能MySQL&gt;中对MVCC的部分介绍</p>
<ul>
<li>MySQL的大多数事务型存储引擎实现的其实都不是简单的行级锁。<strong>基于提升并发性能的考虑</strong>, 它们一般都同时实现了多版本并发控制(MVCC)。不仅是MySQL, 包括Oracle,PostgreSQL等其他数据库系统也都实现了MVCC, 但各自的实现机制不尽相同, 因为MVCC没有一个统一的实现标准。</li>
<li>可以认为MVCC是行级锁的一个变种, 但是它在很多情况下避免了加锁操作, 因此开销更低。虽然实现机制有所不同, 但大都实现了非阻塞的读操作，写操作也只锁定必要的行。</li>
<li>MVCC的实现方式有多种, 典型的有乐观(optimistic)并发控制 和 悲观(pessimistic)并发控制。</li>
<li>MVCC只在 <code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 两个隔离级别下工作。其他两个隔离级别够和MVCC不兼容, 因为 <code>READ UNCOMMITTED</code> 总是读取最新的数据行, 而不是符合当前事务版本的数据行。而 <code>SERIALIZABLE</code> 则会对所有读取的行都加锁。</li>
</ul>
</blockquote>
<p>了解mvcc需要先了解几个概念：</p>
<h3 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h3><p>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。</p>
<p>对于我们日常的操作，如：select … lock in share mode(共享锁)，select …for update、update、insert、delete(排他锁)都是一种当前读。</p>
<p>测试：</p>
<table>
<thead>
<tr>
<th>时间线</th>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>begin</td>
<td>begin</td>
</tr>
<tr>
<td>1</td>
<td>select … where id =1 lock in share mode</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td></td>
<td>update where id =1</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>commit</td>
</tr>
<tr>
<td>4</td>
<td>select … where id =1 lock in share mode</td>
<td></td>
</tr>
</tbody></table>
<p>在测试中我们可以看到，即使是在默认的RR隔离级别下，事务A中依然可以读取到事务B最新提交的内</p>
<p>容，因为在查询语句后面加上了 lock in share mode 共享锁，此时是当前读操作。当然，当我们</p>
<p>加排他锁的时候，也是当前读操作。</p>
<h3 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h3><p>简单的select（不加锁）就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，</p>
<p>不加锁，是非阻塞读。</p>
<p>• Read Committed：每次select，都生成一个快照读。</p>
<p>• Repeatable Read：开启事务后第一个select语句才是快照读的地方。</p>
<p>• Serializable：快照读会退化为当前读。</p>
<p>测试:</p>
<table>
<thead>
<tr>
<th>时间线</th>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>begin</td>
<td>begin</td>
</tr>
<tr>
<td>1</td>
<td>select … where id =1</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td></td>
<td>update where id =1</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>commit</td>
</tr>
<tr>
<td>4</td>
<td>select … where id =1</td>
<td></td>
</tr>
</tbody></table>
<p>在测试中,我们看到即使事务B提交了数据,事务A中也查询不到。 原因就是因为普通的select是快照</p>
<p>读，而在当前默认的RR隔离级别下，开启事务后<strong>第一个select语句才是快照读</strong>的地方，后面执行相同</p>
<p>的select语句都是从快照中获取数据，可能不是当前的最新数据，这样也就<strong>保证了可重复读</strong>。</p>
<p>MVCC的具体实现，还需要依赖于数据库记录中的三个隐式字段、undo log日志、readView。</p>
<p>接下来，我们再来介绍一下InnoDB引擎的表中涉及到的隐藏字段 、undolog 以及 readview，从</p>
<p>而来介绍一下MVCC的原理。</p>
<h3 id="隐藏字段"><a href="#隐藏字段" class="headerlink" title="隐藏字段"></a>隐藏字段</h3><p><img src="img/image-20220526151613182.png" alt="image-20220526151613182"></p>
<p><strong>undolog</strong></p>
<p>回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志。</p>
<p>当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。 </p>
<p>而update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会立即被删除。</p>
<h3 id="版本链"><a href="#版本链" class="headerlink" title="版本链"></a>版本链</h3><p><img src="img/image-20220526152817702.png" alt="image-20220526152817702"></p>
<p>不同事务或相同事务对同一条记录进行修改，会导致该记录的undolog生成一条记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录。事务id递增</p>
<p>对了，undolog是逻辑日志，记录反向sql，这里形象一点，图里写的是数据</p>
<h3 id="read-view"><a href="#read-view" class="headerlink" title="read view"></a>read view</h3><p>ReadView（读视图）是 快照读 SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务（未提交的）id。</p>
<p>ReadView中包含了四个核心字段：</p>
<p><img src="img/image-20220526153014534.png" alt="image-20220526153014534"></p>
<p>而在readview中就规定了版本链数据的访问规则：</p>
<p>可见性比较算法，</p>
<p>trx_id 代表当前undolog版本链对应事务ID。事务id自增。</p>
<p><img src="img/image-20220526153034569.png" alt="image-20220526153034569"></p>
<p>不同的隔离级别，生成ReadView的时机不同：</p>
<ul>
<li><p>READ COMMITTED ：在事务中每一次执行快照读时生成ReadView。</p>
</li>
<li><p>REPEATABLE READ：仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。</p>
</li>
</ul>
<p>RC隔离级别</p>
<p>RC隔离级别下，在事务中每一次执行快照读时生成ReadView。</p>
<p><img src="img/image-20220526153258355.png" alt="image-20220526153258355"></p>
<p>下面这张图是总结起来的，不难理解，如果事务3已经提交，那么最小活动事务id就变4了，此时修改记录里的事务id也是4，第一轮4去比对都失败，根据ptr去undo log找到事务id为3那条数据，拿3去比符合第二条，3&lt;当前最小活动事务id，说明3已经提交，与是读取这条数据，<strong>这不就是read commit rc 读已提交吗？</strong></p>
<p><img src="img/image-20220526152731986.png" alt="image-20220526152731986"></p>
<p> RR隔离级别</p>
<p>RR隔离级别下，仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。 而RR 是可重复读，在一个事务中，执行两次相同的select语句，查询到的结果是一样的。</p>
<p>那MySQL是如何做到可重复读的呢? 我们简单分析一下就知道了</p>
<p><img src="img/image-20220526153901239.png" alt="image-20220526153901239"></p>
<p>不难看出，因为readview一样（此read view是此事务第一次select时创建的），那么同一个事务 内 去多次seclet读取数据，用的readview都一样，读取的数据版本肯定一样，数据也肯定一样，<strong>这不就是repeatable read rr 可重复读吗？</strong></p>
<p>总的来说：</p>
<p>一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：</p>
<ul>
<li>如果记录的 trx_id 值小于 Read View 中的 <code>min_trx_id</code> 值，表示这个版本的记录是在创建 Read View <strong>前</strong>已经提交的事务生成的，所以该版本的记录对当前事务<strong>可见</strong>。</li>
<li>如果记录的 trx_id 值大于等于 Read View 中的 <code>max_trx_id</code> 值，表示这个版本的记录是在创建 Read View <strong>后</strong>才启动的事务生成的，所以该版本的记录对当前事务<strong>不可见</strong>。</li>
<li>如果记录的 trx_id 值在 Read View 的min_trx_id和max_trx_id之间，需要判断 trx_id 是否在 m_ids 列表中：<ul>
<li>如果记录的 trx_id <strong>在</strong> <code>m_ids</code> 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务<strong>不可见</strong>。</li>
<li>如果记录的 trx_id <strong>不在</strong> <code>m_ids</code>列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务<strong>可见</strong>。</li>
</ul>
</li>
</ul>
<h3 id="Read-Commit级别是如何解决脏读的？"><a href="#Read-Commit级别是如何解决脏读的？" class="headerlink" title="Read Commit级别是如何解决脏读的？"></a>Read Commit级别是如何解决脏读的？</h3><p>先说结论：<strong>通过改变锁的释放时机来解决脏读问题</strong>。</p>
<p>首先先了解一下为什么会出现脏读？原因就是在<code>未提交读</code>这个级别下，<strong>当事务A修改了数据之后就立马释放了锁</strong>，因此事务B可以读取到这个未提交的数据。</p>
<p>在<code>已提交读</code>级别下<strong>写操作加的锁会到事务提交后释放</strong>，所以事务B不会读到事务A未提交的数据，通过改变锁的释放时机解决了脏读的问题。</p>
<p>Read Repeatable级别是如何解决不可重复读的？</p>
<p>结论：<code>可重复读</code>级别就是通过<code>MVCC</code>机制来解决不可重复读问题的</p>
<p><code>MVCC机制(多版本并发控制)</code>就我个人理解来说其实就是给每行数据都添加了几个隐藏字段，用来表示数据的版本号，即<strong>一个数据在mysql中会有多个不同的版本</strong>。</p>
<blockquote>
<p>MVCC就是给每一行都都有个事务版本号，假设一条链表第一个节点是最新的数据，越后数据越旧，当有一个快照读操作过来后，会遍历链表，按照 <strong>可见性算法</strong> 找到第一个允许当前事务可见的数据。</p>
<p>普通乐观锁就是加版本号比大小，mvcc也算是乐观锁的一种实现吧，不是单纯的拿版本号比大小，而是有一套算法去比。</p>
</blockquote>
<p>有了MVCC之后我们可以把SQL操作分为两类：</p>
<ul>
<li><strong>快照读</strong></li>
</ul>
<p>读取当前事务可见的数据，默认的select操作就是快照读，读的是历史版本的数据。</p>
<ul>
<li><strong>当前读</strong></li>
</ul>
<p>读取最新的数据，除了默认select操作外的<code>select..for update</code>、<code>update</code>、<code>insert</code>、<code>delete</code>等操作都是当前读，读取的都是最新的数据。</p>
<p>现在我们有了MVCC，当事务A执行一个普通的<code>select操作(快照读)</code>,<strong>MySQL会把维护的事务的一个read view保存下来，事务A再次执行select操作 会根据可见性算法  保证 读取到的数据是没有被其他事务操作过的</strong>，因此通过<code>可重复读级别通过MVCC解决了不可重复读问题，顺便解决了部分的幻读问题</code>，没错<strong>MVCC并没有解决所有的幻读问题</strong>，只是解决了一部分，那是如何彻底解决幻读问题的呢？请接着往后看</p>
<h3 id="加餐，如何解决幻读"><a href="#加餐，如何解决幻读" class="headerlink" title="加餐，如何解决幻读"></a>加餐，如何解决幻读</h3><p>我们知道，可重复读隔离级别下，解决了 脏读 和 不可重复度 的 ，但是无法完全解决幻读。</p>
<p><img src="img/image-20220526160104120.png" alt="image-20220526160104120"></p>
<p>从这个实验结果可以看到，即使事务 B 中途插入了一条记录，事务 A 前后两次查询的结果集都是一样的，并没有出现所谓的幻读现象。</p>
<p>读者做的实验之所以看不到幻读现象，是因为<strong>在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的</strong>。</p>
<p>可重复读隔离级是由 MVCC（多版本并发控制）实现的，实现的方式是启动事务后，在执行第一个查询语句后，会创建一个视图（readview）（在rr下才是这样，详细看下面），然后后续的查询语句都用这个视图，「快照读」读的就是这个视图的数据，视图你可以理解为版本数据，这样就使得每次查询的数据都是一样的。</p>
<blockquote>
<p>• Read Committed：每次select，都生成一个快照读。</p>
<p>• Repeatable Read：开启事务后第一个select语句才是快照读的地方。</p>
<p>• Serializable：快照读会退化为当前读。</p>
</blockquote>
<p>MySQL 里除了普通查询是快照度，其他都是<strong>当前读</strong>，比如update、insert、delete，这些语句执行前都会查询最新版本的数据，然后再做进一步的操作。</p>
<p>这很好理解，假设你要 update 一个记录，另一个事务已经 delete 这条记录并且 提交事务了，这样不是会产生冲突吗，所以 update 的时候肯定要知道最新的数据。</p>
<p>另外，<code>select ... for update</code> 这种查询语句是当前读，每次执行的时候都是读取最新的数据。</p>
<p><strong>因此，要讨论「可重复读」隔离级别的幻读现象，是要建立在「当前读」的情况下。</strong></p>
<blockquote>
<p>前面所说的 解决了 部分幻读现象，就是解决  快照读 的 幻读问题的。</p>
</blockquote>
<p><img src="img/image-20220526160351511.png" alt="image-20220526160351511"></p>
<p>这时候，事务 B 插入的记录，就会被事务 A 的第二条查询语句查询到（因为是当前读），这样就会出现前后两次查询的结果集合不一样，这就出现了幻读。</p>
<p>所以，<strong>Innodb 引擎为了解决「可重复读」隔离级别使用「当前读」而造成的幻读问题，就引出了 next-key 临键锁</strong>，就是记录锁（行锁）和间隙锁的组合。</p>
<ul>
<li>记录锁（行锁），锁的是记录本身；</li>
<li>间隙锁，锁的就是两个值之间的空隙，以防止其他事务在这个空隙间插入新的数据，从而避免幻读现象。</li>
</ul>
<p>比如，执行这条语句的时候，会锁住，然后期间如果有其他事务在这个锁住的范围插入数据就会被阻塞。</p>
<p><img src="img/image-20220526160814115.png" alt="image-20220526160814115"></p>
<p>这就避免了幻读。</p>
<p>幻读只有最高隔离级别 serializable解决了，就是靠加临键锁，锁的粒度太大，这也导致性能降低。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>MVCC多版本控制的实现原理就是通过 InnoDB表的隐藏字段、UndoLog 版本链、ReadView来实现的。</p>
<p>事务四大特性靠主要靠两份日志redo log 、 undo log和mvcc和锁保证：</p>
<p>a原子性：undo log  </p>
<blockquote>
<p>回滚日志undolog保证了 要么全成功要么全失败</p>
</blockquote>
<p>c一致性：redo log + undo log</p>
<blockquote>
<p>重做，和回滚日志保证了 数据库 的数据和状态一定能恢复到最初，保证一致性。比如原来name是唯一字段，事务执行前后无论是否失败，name还得是唯一字段</p>
</blockquote>
<p>i隔离性：mvcc （ InnoDB表的隐藏字段+UndoLog 版本链+ReadView）或 锁</p>
<blockquote>
<p>多版本控制，保证了事务不会受其他事务进行的影响，其实就是 脏读 不可重复读 幻读</p>
</blockquote>
<p>d持久性：redo log</p>
<blockquote>
<p>重做日志redolog保证了 事务只要成功无论发生什么，哪怕机器故障，事务的操作也是 持久性 的。</p>
<p>通过wal写前日志，保证数据一定落盘（就算断电也可以通过redolog进行操作保证落盘），详细见上面redolog介绍。</p>
</blockquote>
<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><h2 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a><strong>错误日志</strong></h2><p>错误日志是 MySQL 中最重要的日志之一，它记录了当 mysqld 启动和停止时，以及服务器在运行过程中发生任何严重错误时的相关信息。当数据库出现任何故障导致无法正常使用时，建议首先查看此日志。</p>
<p>该日志是默认开启的，默认存放目录 /var/log/，默认的日志文件名为 mysqld.log 。</p>
<p>查看日志位置：</p>
<p><img src="img/image-20220527211001146.png" alt="image-20220527211001146"></p>
<p>其实就是查看mysql的系统环境变量里面的log_error变量值就是错误日志的存放地址。</p>
<h2 id="二进制日志"><a href="#二进制日志" class="headerlink" title="二进制日志"></a><strong>二进制日志</strong></h2><p>二进制日志（BINLOG）记录了所有的 DDL（数据定义语言）语句和 DML（数据操纵语言）语句，但不包括数据查询（SELECT、SHOW）语句。</p>
<p>作用：</p>
<p>①. 灾难时的数据恢复；</p>
<p>②. MySQL的主从复制。</p>
<p>在MySQL8版本中，默认二进制日志是开启着的</p>
<p>由于日志是以二进制方式存储的，不能直接读取，需要通过二进制日志查询工具 mysqlbinlog 来查看：</p>
<p><img src="img/image-20220527211341254.png" alt="image-20220527211341254"></p>
<p><strong>删除</strong></p>
<p>对于比较繁忙的业务系统，每天生成的binlog数据巨大，如果长时间不清除，将会占用大量磁盘空</p>
<p>间。可以通过以下几种方式清理日志：</p>
<p><img src="img/image-20220527211403715.png" alt="image-20220527211403715"></p>
<h2 id="查询日志"><a href="#查询日志" class="headerlink" title="查询日志"></a><strong>查询日志</strong></h2><p>查询日志中记录了客户端的所有操作语句，而<strong>二进制日志不包含查询数据的SQL语句</strong>。</p>
<p>默认情况下，查询日志是未开启的。</p>
<p><img src="img/image-20220527211852847.png" alt="image-20220527211852847"></p>
<p><img src="img/image-20220527211904545.png" alt="image-20220527211904545"></p>
<h2 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a><strong>慢查询日志</strong></h2><p><img src="img/image-20220527211950369.png" alt="image-20220527211950369"></p>
<p>随着互联网及移动互联网的发展，应用系统的数据量也是成指数式增长，若采用单数据库进行数据存储，存在以下性能瓶颈：</p>
<ol>
<li><p>IO瓶颈：热点数据太多，数据库缓存不足，产生大量磁盘IO，效率较低。 请求数据太多，带宽不够，网络IO瓶颈。</p>
<blockquote>
<p><strong>这里重点说一下，在MySQL内存结构里，有很大一部分（80%）是分给内存缓冲区的，所以你数据量大了，自然内存占得多了，自然会导致缓存不足，而卡顿。缓存的优点也可以这里说一下。</strong></p>
</blockquote>
</li>
<li><p>CPU瓶颈：排序、分组、连接查询、聚合统计等SQL会耗费大量的CPU资源，请求数太多，CPU出现瓶颈。</p>
</li>
</ol>
<p>在业务系统中，为了缓解磁盘IO及CPU的性能瓶颈，到底是垂直拆分，还是水平拆分；具体是分库，还是分表，都需要根据具体的业务需求具体分析。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/08/15/JVM%E7%AC%94%E8%AE%B0/" rel="prev" title="">
      <i class="fa fa-chevron-left"></i> 
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Mysql%E7%AC%94%E8%AE%B0"><span class="nav-number">1.</span> <span class="nav-text">Mysql笔记</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#B-%E6%A0%91%E7%9B%B8%E6%AF%94B-%E6%A0%91%E7%9A%84%E4%BC%98%E7%82%B9"><span class="nav-number">1.1.</span> <span class="nav-text">B+树相比B-树的优点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%AB%98%E5%BA%A6%E4%B8%BA3%E7%9A%84B-%E6%A0%91%E5%AD%98%E5%82%A8%E5%8D%83%E4%B8%87%E7%BA%A7%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="nav-number">1.2.</span> <span class="nav-text">为什么高度为3的B+树存储千万级数据？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%AD%E5%BC%80http%E6%8A%A5%E6%96%87%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1"><span class="nav-number">1.3.</span> <span class="nav-text">揭开http报文的神秘面纱</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9E%B6%E6%9E%84%EF%BC%8C%E6%89%A7%E8%A1%8C%E4%B8%80%E6%9D%A1sql%E8%AF%AD%E5%8F%A5%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88"><span class="nav-number">2.</span> <span class="nav-text">架构，执行一条sql语句发生了什么</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="nav-number">3.</span> <span class="nav-text">事务四大特性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E4%B8%89%E4%B8%AA%E9%97%AE%E9%A2%98"><span class="nav-number">4.</span> <span class="nav-text">并发事务三个问题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">5.</span> <span class="nav-text">事务的隔离级别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%BB%8B%E7%BB%8D"><span class="nav-number">6.</span> <span class="nav-text">存储引擎介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#InnoDB"><span class="nav-number">6.1.</span> <span class="nav-text">InnoDB</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MyISAM"><span class="nav-number">6.2.</span> <span class="nav-text">MyISAM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Memory"><span class="nav-number">6.3.</span> <span class="nav-text">Memory</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84"><span class="nav-number">7.</span> <span class="nav-text">索引结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#b%E6%A0%91"><span class="nav-number">7.1.</span> <span class="nav-text">b树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%88%E5%B8%8C"><span class="nav-number">7.2.</span> <span class="nav-text">哈希</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB"><span class="nav-number">8.</span> <span class="nav-text">索引分类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SQL%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="nav-number">9.</span> <span class="nav-text">SQL性能分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#SQL%E6%89%A7%E8%A1%8C%E9%A2%91%E7%8E%87"><span class="nav-number">9.1.</span> <span class="nav-text">SQL执行频率</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2SQL"><span class="nav-number">9.2.</span> <span class="nav-text">慢查询SQL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#profile%E6%89%A7%E8%A1%8C%E8%80%97%E6%97%B6%E8%AF%A6%E6%83%85"><span class="nav-number">9.3.</span> <span class="nav-text">profile执行耗时详情</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#explain%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92"><span class="nav-number">9.4.</span> <span class="nav-text">explain执行计划</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%88%99"><span class="nav-number">10.</span> <span class="nav-text">索引的使用原则</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E6%B3%95%E5%88%99"><span class="nav-number">10.1.</span> <span class="nav-text">最左前缀法则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2"><span class="nav-number">10.2.</span> <span class="nav-text">范围查询</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%88%97%E8%BF%90%E7%AE%97"><span class="nav-number">10.3.</span> <span class="nav-text">索引列运算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8D%E5%8A%A0%E5%BC%95%E5%8F%B7"><span class="nav-number">10.4.</span> <span class="nav-text">字符串不加引号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2"><span class="nav-number">10.5.</span> <span class="nav-text">模糊查询</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#or%E8%BF%9E%E6%8E%A5%E6%9D%A1%E4%BB%B6"><span class="nav-number">10.6.</span> <span class="nav-text">or连接条件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83%E5%BD%B1%E5%93%8D"><span class="nav-number">10.7.</span> <span class="nav-text">数据分布影响</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SQL%E6%8F%90%E7%A4%BA"><span class="nav-number">10.8.</span> <span class="nav-text">SQL提示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="nav-number">10.9.</span> <span class="nav-text">覆盖索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95"><span class="nav-number">10.10.</span> <span class="nav-text">前缀索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E5%88%97%E7%B4%A2%E5%BC%95%E4%B8%8E%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="nav-number">10.11.</span> <span class="nav-text">单列索引与联合索引</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="nav-number">11.</span> <span class="nav-text">索引设计原则</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SQL%E4%BC%98%E5%8C%96"><span class="nav-number">12.</span> <span class="nav-text">SQL优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#insert%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="nav-number">12.1.</span> <span class="nav-text">insert插入数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E9%94%AE%E4%BC%98%E5%8C%96"><span class="nav-number">12.2.</span> <span class="nav-text">主键优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#order-by%E4%BC%98%E5%8C%96"><span class="nav-number">12.3.</span> <span class="nav-text">order by优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#group-by%E4%BC%98%E5%8C%96"><span class="nav-number">12.4.</span> <span class="nav-text">group by优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#limit%E4%BC%98%E5%8C%96"><span class="nav-number">12.5.</span> <span class="nav-text">limit优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#count%E4%BC%98%E5%8C%96"><span class="nav-number">12.6.</span> <span class="nav-text">count优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#update%E4%BC%98%E5%8C%96"><span class="nav-number">12.7.</span> <span class="nav-text">update优化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A7%86%E5%9B%BE"><span class="nav-number">13.</span> <span class="nav-text">视图</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="nav-number">14.</span> <span class="nav-text">存储过程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="nav-number">15.</span> <span class="nav-text">触发器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%94%81"><span class="nav-number">16.</span> <span class="nav-text">锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E9%94%81"><span class="nav-number">16.1.</span> <span class="nav-text">全局锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%A8%E7%BA%A7%E9%94%81"><span class="nav-number">16.2.</span> <span class="nav-text">表级锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A8%E9%94%81"><span class="nav-number">16.2.1.</span> <span class="nav-text">表锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%83%E6%95%B0%E6%8D%AE%E9%94%81"><span class="nav-number">16.2.2.</span> <span class="nav-text">元数据锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%84%8F%E5%90%91%E9%94%81"><span class="nav-number">16.2.3.</span> <span class="nav-text">意向锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%8C%E7%BA%A7%E9%94%81"><span class="nav-number">16.3.</span> <span class="nav-text">行级锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%8C%E9%94%81"><span class="nav-number">16.3.1.</span> <span class="nav-text">行锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%B4%E9%9A%99%E9%94%81"><span class="nav-number">16.3.2.</span> <span class="nav-text">间隙锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B4%E9%94%AE%E9%94%81"><span class="nav-number">16.3.3.</span> <span class="nav-text">临键锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="nav-number">16.4.</span> <span class="nav-text">总结：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1"><span class="nav-number">17.</span> <span class="nav-text">事务</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">17.1.</span> <span class="nav-text">隔离级别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redo-log"><span class="nav-number">17.2.</span> <span class="nav-text">redo log</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undo-log"><span class="nav-number">17.3.</span> <span class="nav-text">undo log</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bin-log"><span class="nav-number">17.4.</span> <span class="nav-text">bin log</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mvcc"><span class="nav-number">17.5.</span> <span class="nav-text">mvcc</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%93%E5%89%8D%E8%AF%BB"><span class="nav-number">17.5.1.</span> <span class="nav-text">当前读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E7%85%A7%E8%AF%BB"><span class="nav-number">17.5.2.</span> <span class="nav-text">快照读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%90%E8%97%8F%E5%AD%97%E6%AE%B5"><span class="nav-number">17.5.3.</span> <span class="nav-text">隐藏字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%88%E6%9C%AC%E9%93%BE"><span class="nav-number">17.5.4.</span> <span class="nav-text">版本链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#read-view"><span class="nav-number">17.5.5.</span> <span class="nav-text">read view</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Read-Commit%E7%BA%A7%E5%88%AB%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%84%8F%E8%AF%BB%E7%9A%84%EF%BC%9F"><span class="nav-number">17.5.6.</span> <span class="nav-text">Read Commit级别是如何解决脏读的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E9%A4%90%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB"><span class="nav-number">17.5.7.</span> <span class="nav-text">加餐，如何解决幻读</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">17.6.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%97%A5%E5%BF%97"><span class="nav-number">18.</span> <span class="nav-text">日志</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97"><span class="nav-number">18.1.</span> <span class="nav-text">错误日志</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97"><span class="nav-number">18.2.</span> <span class="nav-text">二进制日志</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="nav-number">18.3.</span> <span class="nav-text">查询日志</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="nav-number">18.4.</span> <span class="nav-text">慢查询日志</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">0xiceee</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">0xiceee</span>
  
  
  <span id="sitetime"></span>
  <% if (theme.busuanziStatistics && theme.busuanziStatistics.totalTraffic) { %>
    <span id="busuanzi_container_site_pv" style='display:none'>
        <i class="fa fa-heart-o"></i>
        本站总访问量 <span id="busuanzi_value_site_pv" class="white-color"></span>
    </span>
<% } %>
<% if (theme.busuanziStatistics && theme.busuanziStatistics.totalNumberOfvisitors) { %>
    <span id="busuanzi_container_site_uv" style='display:none'>
        人次,&nbsp;访客数 <span id="busuanzi_value_site_uv" class="white-color"></span> 人.
    </span>
<% } %>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>
<script language=javascript>
    function siteTime() {
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth() + 1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();
        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数 */
        var t1 = Date.UTC(2017, 09, 11, 00, 00, 00); //北京时间2018-2-13 00:00:00
        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
        var diff = t2 - t1;
        var diffYears = Math.floor(diff / years);
        var diffDays = Math.floor((diff / days) - diffYears * 365);
        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes);
        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds);
        document.getElementById("sitetime").innerHTML = "本站已运行 " +diffYears+" 年 "+diffDays + " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
    }/*因为建站时间还没有一年，就将之注释掉了。需要的可以取消*/
    siteTime();
</script>


<script>
    $(document).ready(function () {

        var int = setInterval(fixCount, 50);  // 50ms周期检测函数
        var pvcountOffset = 80000;  // 初始化首次数据
        var uvcountOffset = 20000;

        function fixCount() {
            if (document.getElementById("busuanzi_container_site_pv").style.display != "none") {
                $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + pvcountOffset);
                clearInterval(int);
            }
            if ($("#busuanzi_container_site_pv").css("display") != "none") {
                $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + uvcountOffset); // 加上初始数据 
                clearInterval(int); // 停止检测
            }
        }
    });
</script>
        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
