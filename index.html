<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>Hexo</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?4ebc77cc93c9a8d2365cc0589b5171b1";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="تشغيل شريط التصفح">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>معلومات</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>التصنيفات</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>الأرشيفات</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/17/Proxy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/17/Proxy/" class="post-title-link" itemprop="url">Proxy</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">نُشر في</span>
              

              <time title="أُنشأ: 2021-11-17 02:30:49 / عُدل: 02:31:14" itemprop="dateCreated datePublished" datetime="2021-11-17T02:30:49+08:00">2021-11-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><blockquote>
<p>spring中AOP里的切点切面是啥，aop底层机制就是动态代理</p>
</blockquote>
<blockquote>
<p>给一个对象提供一个代理，就是制造一个代理对象来控制对真实对象的访问。</p>
<p>代理模式是一种结构型设计模式。</p>
<p>简而言之，代理模式就是，设置一个代理对象来达到：</p>
<p>​                                                            在不修改原对象（真实对象）的前提下，</p>
<p>​                                                                扩展原对象（真实对象）功能，</p>
<p>​                                                                    简化访问原对象（真实对象）。</p>
</blockquote>
<p>首先，代理模式分为</p>
<pre><code>                    - 静态代理：自己实现代理模式
                    - 动态代理：由jdk或者第三方包（cglib）来实现
</code></pre>
<p>代理模式中有三种角色：</p>
<ul>
<li><p>Subject抽象角色：声明真实对象和代理对象的共同接口</p>
</li>
<li><p>Proxy代理角色：代理对象角色内部含有对真实对象的引用，从而可以操作真实对象。同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装</p>
</li>
<li><p>RealSubject真实角色：代理角色所代表的真实对象，是代理对象要引用的对象</p>
</li>
<li><p>Client客户（测试类）：通过调用代理对象来进行业务操作，核心业务由真实对象提供，通常代理对象会额外增加一些操作</p>
</li>
</ul>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>自己实现代理模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;真实对象和代理对象，公用的接口类</span><br><span class="line">public interface UserService &#123;</span><br><span class="line">    void deal();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class UserServiceImpl implements UserService&#123;</span><br><span class="line">    &#x2F;&#x2F;真实业务</span><br><span class="line">    public void deal() &#123;</span><br><span class="line">        System.out.println(&quot;RealSubject对用户一系列操作&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>那么现在想要给真实业务增加操作怎么办</p>
<ul>
<li>思路1 ：在实现类上增加代码 【麻烦！】</li>
<li>思路2：使用代理来做，能够不改变原来的业务情况下，实现此功能就是最好的了</li>
</ul>
<p>思路二，就是使用代理模式，核心就是：在不修改原对象（真实对象）的前提下，</p>
<p>​                                                                    扩展原对象（真实对象）功能，</p>
<p>​                                                                    简化访问原对象（真实对象）。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class UserServiceProxy implements UserService&#123;</span><br><span class="line"></span><br><span class="line">    private UserServiceImpl userServiceImplInProxy;</span><br><span class="line">    &#x2F;&#x2F;算是一个构造方法吧，把真实对象传递进来</span><br><span class="line">    public void setUserServiceImpl(UserServiceImpl userServiceImpl) &#123;</span><br><span class="line">        &#x2F;&#x2F;userServiceImplInProxy是真实对象userServiceImpl的引用</span><br><span class="line">        this.userServiceImplInProxy&#x3D;userServiceImpl;</span><br><span class="line">&#125;</span><br><span class="line">    public void deal() &#123;</span><br><span class="line">        &#x2F;&#x2F;代理对象一般会增加一些操作</span><br><span class="line">        System.out.println(&quot;Proxy对象增加的一些列操作&quot;);</span><br><span class="line">        &#x2F;&#x2F;实际还是在用真实对象处理</span><br><span class="line">        &#x2F;&#x2F;userServiceImplInProxy是真实对象userServiceImpl的引用</span><br><span class="line">        userServiceImplInProxy.deal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class ClientTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;真实对象去做真实业务</span><br><span class="line">        UserServiceImpl userService &#x3D; new UserServiceImpl();</span><br><span class="line">        &#x2F;&#x2F;代理对象</span><br><span class="line">        UserServiceProxy userServiceProxy &#x3D; new UserServiceProxy();</span><br><span class="line">        &#x2F;&#x2F;真实对象传递给代理对象使用，但是实际处理真实业务时，代理对象里的业务是直接调用真实对象完成的</span><br><span class="line">        userServiceProxy.setUserServiceImpl(userService);</span><br><span class="line">        &#x2F;&#x2F;地阿里对象执行业务</span><br><span class="line">        userServiceProxy.deal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Proxy对象增加的一些列操作</span><br><span class="line">RealSubject对用户一系列操作</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>







<p>总结一下静态代理的好处:</p>
<ul>
<li><p>可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情</p>
</li>
<li><p>公共的业务由代理来完成 . 实现了业务的分工 </p>
</li>
<li><p>公共业务发生扩展时变得更加集中和方便</p>
</li>
</ul>
<blockquote>
<p>通过静态代理，我们达到了功能增强的目的，而且没有侵入原代码，这是静态代理的一个优点。</p>
</blockquote>
<p>缺点 :</p>
<ul>
<li><p>类多了 , 多了代理类 , 工作量变大了 . 开发效率降低</p>
</li>
<li><p>当接口需要增加、删除、修改方法的时候，目标对象与代理类都要同时修改，不易维护</p>
</li>
</ul>
<p>想要静态代理的好处，又不想要静态代理的缺点，所以 , 就有了动态代理 !</p>
<blockquote>
<p>思想：</p>
<p>我们在不改变原来的代码的情况下，实现了对原有功能的增强，这是AOP中最核心的思想</p>
<p>传统的开发：纵向开发 dao service servlet 前端</p>
<p>横向的编程：aop底层实现机制，增加一个代理类，横切进去</p>
</blockquote>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><blockquote>
<p>动态代理在Java中有着广泛的应用，比如Spring AOP、Hibernate数据查询、测试框架的后端mock、RPC远程调用、Java注解对象获取、日志、用户鉴权、全局性异常处理、性能监控，甚至事务处理等。</p>
<p>动态代理的角色和静态代理的一样 .</p>
<p>动态代理的代理类是动态生成的 . 静态代理的代理类是我们提前写好的</p>
<p>动态代理分为两类 : 一类是基于接口动态代理 , 一类是基于类的动态代理</p>
<p>基于接口的动态代理—-JDK动态代理<br>基于类的动态代理–cglib<br>现在用的比较多的是 javasist 来生成动态代理 . 百度一下javasist<br>我们这里使用JDK的原生代码来实现，其余的道理都是一样的！</p>
<hr>
<p>为什么类可以动态的生成？</p>
<p>Java虚拟机类加载过程主要分为五个阶段：加载、验证、准备、解析、初始化。其中加载阶段需要完成以下3件事情：</p>
<p>通过一个类的全限定名来获取定义此类的二进制字节流</p>
<p>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</p>
<p>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据访问入口</p>
<p>动态代理就是想办法，根据接口或目标对象，计算出代理类的字节码，然后再加载到JVM中使用。</p>
</blockquote>
<p>两种最常见的方式：</p>
<p>通过实现接口的方式 -&gt; JDK动态代理<br>通过继承类的方式 -&gt; CGLIB动态代理</p>
<h3 id="jdk代理"><a href="#jdk代理" class="headerlink" title="jdk代理"></a>jdk代理</h3><blockquote>
<p>只能通过实现接口的方式</p>
<p>原理：针对内存中Class对象，使用类加载器动态为目标对象创建代理类</p>
<p>​        代理类 是动态创建的，代理类  和  被代理对象   实现相同接口 </p>
<p>​    被代理对象 必须要实现 接口 （JDK代理 只能针对接口 进行代理 ）</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface UserDao &#123;</span><br><span class="line">    boolean delete(int id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class UserDaoImpl implements UserDao&#123;</span><br><span class="line">    public boolean delete(int id) &#123;</span><br><span class="line">        System.out.println(&quot;这里是RealSubject真实对象的方法，执行后删除了&quot;+id+&quot;号员工&quot;);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class MyProxy implements InvocationHandler &#123;    private UserDao userDao;    public MyProxy(UserDao userDao)&#123;        this.userDao&#x3D;userDao;    &#125;    public UserDao createProxy()&#123;        return (UserDao) Proxy.newProxyInstance(userDao.getClass().getClassLoader(), userDao.getClass().getInterfaces(), this);    &#125;    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;        &#x2F;&#x2F;重写invoke里增加代理对象需要扩展的业务，这里只输出一句话        System.out.println(&quot;代理对象在调用真实对象之前进行功能扩展&quot;);        &#x2F;&#x2F;把真实对象以及需要的参数传进去，用真实对象调用真实业务        return method.invoke(userDao, args);    &#125;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Client1 &#123;    public static void main(String[] args) &#123;        UserDao realUserDao &#x3D;new UserDaoImpl();        &#x2F;&#x2F;创建代理类的实体类并吧等下创建代理对象需要用到的真实对象传进去        MyProxy myProxy &#x3D; new MyProxy(realUserDao);        &#x2F;&#x2F;用上面的实体 创建代理对象，这里可以看到共用一个接口，这也是为啥jdk动态代理必须要有接口        UserDao proxyUserDao &#x3D; myProxy.createProxy();        &#x2F;&#x2F;用代理对象执行方法        proxyUserDao.delete(8);    &#125;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其实mybatis里的mapper代理本质也是jdk代理，dao包里只需要写好接口，</p>
<p>搬运一下网上写的：</p>
<p>1、最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？</p>
<p>答：Dao接口，就是人们常说的Mapper接口，接口的全限名，就是映射文件中的namespace的值，接口的方法名，就是映射文件中MappedStatement的id值，接口方法内的参数，就是传递给sql的参数。</p>
<p>Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatement，举例：com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到namespace为com.mybatis3.mappers.StudentDao下面id = findStudentById的MappedStatement。在Mybatis中，每一个<select>、<insert>、<update>、<delete>标签，都会被解析为一个MappedStatement对象。</p>
<p>Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。</p>
<p>Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。</p>
<p>2、Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？</p>
<p>答：Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。</p>
<p>它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。</p>
<p>当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。</p>
</blockquote>
<h3 id="cglib代理"><a href="#cglib代理" class="headerlink" title="cglib代理"></a>cglib代理</h3><p>JDK 动态代理缺点是 为目标对象（接口）生成代理对象 ，对于不使用接口的业务类，无法使用JDK动态代理。</p>
<p>有点感冒，懒得写了，都写到注释里了，看代码吧</p>
<p>导入pom文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;cglib&#x2F;cglib --&gt;&lt;dependency&gt;    &lt;groupId&gt;cglib&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;cglib&lt;&#x2F;artifactId&gt;    &lt;version&gt;3.3.0&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class ProductDao &#123;    public  void  add()&#123;        System.out.println(&quot;真实对象执行真实业务，添加用户&quot;);    &#125;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Myproxy implements MethodInterceptor &#123;    private ProductDao productDao;    public Myproxy(ProductDao productDao) &#123;        this.productDao &#x3D; productDao;    &#125;    public ProductDao createProxy()&#123;        &#x2F;&#x2F;Enhancer 类是cglib创建代理对象的核心对象，先把它的实体对象搞出来        Enhancer enhancer &#x3D;new Enhancer();        &#x2F;&#x2F;可以看到，enhancer 的类对象不需要接口，而是直接找到类的class文件就可以        enhancer.setSuperclass(productDao.getClass());        &#x2F;&#x2F;设置回调函数，类似于jdk代理的invoke方法        enhancer.setCallback(this);        &#x2F;&#x2F;创建代理类对象并返回        return (ProductDao)enhancer.create();    &#125;    public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123;        System.out.println(&quot;代理对象进行业务扩展，记录日志&quot;);        return method.invoke(productDao, args);    &#125;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Client2 &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F;先创建真实对象        ProductDao productDao &#x3D; new ProductDao();        &#x2F;&#x2F;创建好代理类的实体对象把真实对象传入我们创建代理对象的类，因为创建代理对象的类创建代理对象需要真实对象，因为核心业务还是真实对象在做        Myproxy myproxy &#x3D; new Myproxy(productDao);        &#x2F;&#x2F;创建代理对象并执行业务        ProductDao proxy &#x3D; myproxy.createProxy();        proxy.add();    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">代理对象进行业务扩展，记录日志真实对象执行真实业务，添加用户Process finished with exit code 0</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><h2 id="描述动态代理的几种实现方式？分别说出相应的优缺点"><a href="#描述动态代理的几种实现方式？分别说出相应的优缺点" class="headerlink" title="描述动态代理的几种实现方式？分别说出相应的优缺点"></a>描述动态代理的几种实现方式？分别说出相应的优缺点</h2><p>代理可以分为 “静态代理” 和 “动态代理”，动态代理又分为 “JDK动态代理” 和 “CGLIB动态代理” 实现。</p>
<h3 id="静态代理："><a href="#静态代理：" class="headerlink" title="静态代理："></a>静态代理：</h3><p>代理对象和实际对象都继承了同一个接口，在代理对象中指向的是实际对象的实例，这样对外暴露的是代理对象而真正调用的是 Real Object</p>
<p><strong>优点</strong>：可以很好的保护实际对象的业务逻辑对外暴露，从而提高安全性。<br><strong>缺点</strong>：不同的接口要有不同的代理类实现，会很冗余</p>
<h3 id="JDK-动态代理："><a href="#JDK-动态代理：" class="headerlink" title="JDK 动态代理："></a>JDK 动态代理：</h3><p>为了解决静态代理中，生成大量的代理类造成的冗余；</p>
<p>JDK 动态代理只需要实现 <strong>InvocationHandler 接口</strong>，<strong>重写 invoke 方法</strong>便可以完成代理的实现，</p>
<p>jdk的代理是利用<strong>反射</strong>生成代理类 Proxyxx.class 代理类字节码，并生成对象</p>
<p><strong>jdk动态代理之所以只能代理接口是因为代理类本身已经extends了Proxy，而java是不允许多重继承的，但是允许实现多个接口</strong></p>
<p><strong>优点</strong>：解决了静态代理中冗余的代理实现类问题。</p>
<p><strong>缺点</strong>：JDK 动态代理是基于接口设计实现的，如果没有接口，会抛异常。</p>
<h3 id="CGLIB-代理："><a href="#CGLIB-代理：" class="headerlink" title="CGLIB 代理："></a>CGLIB 代理：</h3><p>由于 JDK 动态代理限制了只能基于接口设计，而对于没有接口的情况，JDK方式解决不了；</p>
<p><strong>CGLib 采用了非常底层的字节码技术</strong>，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，<strong>顺势织入横切逻辑</strong>，来完成动态代理的实现。</p>
<p><strong>实现方式实现 MethodInterceptor 接口，重写 intercept 方法，通过 Enhancer 类的回调方法来实现。</strong></p>
<p>但是CGLib在创建代理对象时所花费的时间却比JDK多得多，所以对于单例的对象，因为无需频繁创建对象，用CGLib合适，反之，使用JDK方式要更为合适一些。</p>
<p>同时，由于CGLib由于是采用动态创建子类的方法，对于final方法，无法进行代理。</p>
<p><strong>优点</strong>：没有接口也能实现动态代理，而且采用字节码增强技术，性能也不错。</p>
<p><strong>缺点</strong>：技术实现相对难理解些。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/28/i-luv-CJ/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/28/i-luv-CJ/" class="post-title-link" itemprop="url">i luv CJ -szy</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">نُشر في</span>
              

              <time title="أُنشأ: 2021-04-28 22:41:59 / عُدل: 22:59:27" itemprop="dateCreated datePublished" datetime="2021-04-28T22:41:59+08:00">2021-04-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="java基本设计结构"><a href="#java基本设计结构" class="headerlink" title="java基本设计结构"></a>java基本设计结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstSample</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;We will not use &#x27;Hello,World!&#x27;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>首先Java区分大小写，大小写拼写错误，程序无法运行；</li>
<li>关键字<code>public</code>   称为access modifier 访问修饰符  <ul>
<li>用于控制程序的其他部分对这段代码的访问级别</li>
</ul>
</li>
<li>类是构建所有Java应用程序和applet的构建块 <ul>
<li>Java应用程序中的全部内容都必须放置在类中</li>
</ul>
</li>
<li> <code>class</code>后面跟着类名  <code>FirstSample</code></li>
</ol>
<blockquote>
<p>类名以字母开头，后面可以跟字母和数字的随意组合，但是不能使用关键字</p>
<p>多个单词使用骆驼命名法 CamelCase</p>
</blockquote>
<ol start="5">
<li><p>{ }一对大括号表示方法块的开始和结束</p>
</li>
<li><p><code> System.out.println</code> </p>
<p>这里是使用System.out对象调用了它的println方法，点号 . 用于调用方法</p>
<blockquote>
<p>object.method(parameters参数)</p>
</blockquote>
</li>
<li><p>注释</p>
<blockquote>
<blockquote>
<p>注释从   //   开始到本行结束</p>
</blockquote>
<blockquote>
<p>更长的注释用/*  和   */框起来</p>
</blockquote>
<blockquote>
<p>还有一种可以自动生成文档，以/**开始 */结束 （后面再说具体使用）</p>
</blockquote>
</blockquote>
</li>
<li><p>数据类型  8种 primitive type</p>
<blockquote>
<p>四种整型    int，short，long，byte</p>
<p>两种浮点型  float，double</p>
<p>一种字符类型 char (用来表示Unicode编码的代码单元)</p>
<p>一种表示真值的boolean</p>
</blockquote>
</li>
<li><p>整型</p>
</li>
<li><p>每个变量都有一个类型type，声明变量时，先指定类型，然后是变量名</p>
</li>
</ol>
<blockquote>
<p>变量名必须是由字母开头并由字母或数字构成的序列</p>
<p>Java中字母范围蛮大的，可用Character类的isJavaIdentifierStart  和  isJavaIdentifierPart</p>
</blockquote>
<ul>
<li>变量的声明尽可能靠近变量第一次使用的地方</li>
</ul>
<ol start="11">
<li><p>声明变量后，必须用赋值语句对变量进行显示初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a ;</span><br><span class="line">a = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">12</span>;</span><br></pre></td></tr></table></figure></li>
<li><blockquote>
<p>Java10 开始，对于局部变量，如果可以从变量的初始值判断出它的类型，就不用再声明类型</p>
<p>直接用关键字var而无需指定类型</p>
<p><code> var vacationDays = 12;   //vacationDays is an int</code> </p>
<p><code> var greeting = &quot;Hello&quot;   //  greetinng is a String</code> </p>
</blockquote>
</li>
<li><p><code>final </code>关键字来指示常量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Constants &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        </span><br><span class="line">        final double CM_PER_INCH &#x3D; 2.45;</span><br><span class="line">        double paperWidth &#x3D; 8.5;</span><br><span class="line">        double paperHeight &#x3D; 11;</span><br><span class="line">        System.out.println(&quot;Paper sizee in in centermeters:&quot;</span><br><span class="line">        + paperWidth*CM_PER_INCH + &quot;by&quot; + paperHeight*CM_PER_INCH);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>final常量只能被赋值一次，一旦赋值就不能再改了</li>
<li>一般常量名字用全大写</li>
</ul>
</li>
<li><p> class constant  类常量</p>
</li>
</ol>
<pre><code>可以在一个类中的多个方法使用

一般用static final设置一个类常量

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Constants2 &#123;</span><br><span class="line"></span><br><span class="line">    public static final double CM_PER_INCH &#x3D; 2.54;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        double paperWidth &#x3D; 8.5;</span><br><span class="line">        double paperHeight &#x3D; 11;</span><br><span class="line">        System.out.println(&quot;Paper size in centermeters is&quot;+</span><br><span class="line">                           paperHeight*CM_PER_INCH +&quot;by&quot;+ paperWidth*CM_PER_INCH);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

- 类常量定义于main方法外部--因此在同一个类的其他方法里也可以使用此类常量
- 此外，如果一个常量被声明为public，那么其他类的方法也可以用这个常量 就比如这个Constants2.CM_PER_INCH
</code></pre>
<ol start="15">
<li><p>枚举类型</p>
<blockquote>
<p>有时候变量的取值只在一个有限的集合内，防止出错，可以自定义枚举型</p>
</blockquote>
<p><code> enum Size &#123;SMALL , MEDIUM , LARGE , EXTRA_LARGE&#125;</code></p>
<p>定义好后就可以声明这种类型的变量：</p>
<p><code>Size s = Size.MEDIUM;</code></p>
<ul>
<li>Size类型的变量只能存储这个类型声明中给定的某个枚举值，或者特殊值null，null表示没有设置任何值</li>
<li>后面详细介绍枚举类型</li>
</ul>
</li>
<li><p>运算符</p>
<blockquote>
<p>算术运算符：+ ， -  ， * ， /    加，减，乘，除</p>
<pre><code>                    %取余

                    /运算的两个数都是整数时 为整数除法

                    15/2 = 7    

                    15.0/2 = 7.5

                    15%2 = 1

                    注意：整数被0除会产生异常，浮点数被0除会得到无穷大或NaN结果
</code></pre>
</blockquote>
<blockquote>
<p>数学函数与常量： 平方根Math.sqrt()             </p>
<pre><code>                            幂运算pow(x,a)          - 导包后就不用Math.了 ` import static java.lang.Math`

                            Math类还有常用三角函数sin，cos，tan等

                            表示Math.PI和 Math.E 数学常量
</code></pre>
<p>​                                </p>
</blockquote>
</li>
<li><p>数值类型之间的转换</p>
<ul>
<li>当一个二元运算符连接两个值时 ：<ul>
<li>两个数中有一个为double，则另一个也变double</li>
<li>否则有一个float，另一个变float</li>
<li>然后是long</li>
<li>最后是int</li>
</ul>
</li>
</ul>
</li>
<li><p>强制类型转换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 	 	<span class="keyword">double</span> x = <span class="number">9.997</span>;</span><br><span class="line"><span class="comment">//强制截断小数部分将浮点值转换为整型</span></span><br><span class="line">        <span class="keyword">int</span> nx = (<span class="keyword">int</span>)x;  <span class="comment">// nx=9</span></span><br><span class="line"><span class="comment">//舍入运算,得到最接近的数</span></span><br><span class="line">        <span class="keyword">int</span> nx2 = (<span class="keyword">int</span>) Math.round(x);   <span class="comment">//nx2=10</span></span><br></pre></td></tr></table></figure></li>
<li><p>结合赋值和运算符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int x;</span><br><span class="line">x +&#x3D; 4;    &#x2F;&#x2F; x&#x3D; x+4</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：如果<code> x+=3.5;</code>则会自动强制类型转换为x的类型int ( 截断小数部分强转)</p>
</blockquote>
</li>
</ol>
<ol start="20">
<li>自增与自减运算符  </li>
</ol>
<p><code> i++</code>       <code>i--</code></p>
<p><code>++i</code>       <code>--i</code></p>
<ol start="21">
<li>关系和boolean运算符</li>
</ol>
<blockquote>
<p>检测相等性:  <code>==</code></p>
<p>不等性检测:<code>!=</code></p>
<p>与:&amp;&amp;       -   x&amp;&amp;y 如果x为false则y不再运算哦</p>
<p>或:||        -    x||y一样的,如果x为true则y不再运算了</p>
<p>&lt;,&gt;,&gt;=,&lt;=</p>
<blockquote>
<p>java支持一个三元操作符:</p>
<p>condition ? expression1 :  expression2</p>
<p>x&lt;y ? x: y 会返回x和y中较小的一个</p>
</blockquote>
</blockquote>
<ol start="22">
<li>位运算符</li>
</ol>
<ol start="23">
<li>括号与运算符级别</li>
</ol>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ol start="24">
<li><blockquote>
<p> java没有内置的字符串类型，而是在标准的java类库中提供了一个预定义类，很自然的就叫做String</p>
<blockquote>
<p>每个双引号括起来的字符串都是String类的一个实例</p>
</blockquote>
</blockquote>
</li>
</ol>
<h4 id="1-子串"><a href="#1-子串" class="headerlink" title="1.子串"></a>1.子串</h4><ol start="25">
<li><p><code>substring</code> 方法可以从何一个较大的字符串提取出一个子串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String greeting &#x3D; &quot;Hello&quot;;</span><br><span class="line">String s &#x3D; greeting.substring(0,3);</span><br><span class="line">&#x2F;&#x2F;s就被赋值为“Hel”</span><br><span class="line">&#x2F;&#x2F; 第一个参数从哪个下标开始，第二个参数是第一个不想复制的位置</span><br><span class="line">&#x2F;&#x2F; 3-0 就是新字符串长度</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="2-拼接"><a href="#2-拼接" class="headerlink" title="2.拼接"></a>2.拼接</h4><ol start="26">
<li><p>Java允许使用+号连接（拼接）字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String a &#x3D; &quot;ab&quot;;</span><br><span class="line">String b &#x3D; &quot;cd&quot;;</span><br><span class="line">String c&#x3D; &quot;ef&quot;;</span><br><span class="line">String x &#x3D; a + b + c;   &#x2F;&#x2F;  x &#x3D; &quot;abcdef&quot;</span><br></pre></td></tr></table></figure>

<p>当一个字符串与一个非字符串的值进行拼接时，后者会转成字符串</p>
<blockquote>
<p>后面会说到，任何一个Java对象都可以转换成字符串</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int age &#x3D; 12;</span><br><span class="line">String rating &#x3D; &quot;PG&quot; + age;  &#x2F;&#x2F; rating &#x3D; &quot;PG130&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;一般这样用</span><br><span class="line">System.out.println(&quot;This answer is :&quot; + answer);</span><br></pre></td></tr></table></figure></li>
<li><p>静态方法<code>join</code>：把多个字符串放在一起，用一个界定符分割</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String all &#x3D; String.join(&quot;&#x2F;&quot;,&quot;S&quot;,&quot;M&quot;,&quot;L&quot;,&quot;XL&quot;);</span><br><span class="line">       &#x2F;&#x2F; all &#x3D; &quot;S&#x2F;M&#x2F;L&#x2F;XL&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>Java11 中，提供一个<code>repeat</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String repeated = <span class="string">&quot;Java&quot;</span>.repeat(<span class="number">3</span>);</span><br><span class="line">       <span class="comment">// repeated = &quot;JavaJavaJava&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="3-不可变字符串"><a href="#3-不可变字符串" class="headerlink" title="3.不可变字符串*"></a>3.不可变字符串*</h4><ol start="29">
<li><p>由于不能修改Java字符串中的单个字符串，所以Java文档中将String类对象称为是不可变的immutable</p>
<blockquote>
<p>修改字符串和拼接字符串的效率问题</p>
</blockquote>
</li>
</ol>
<h4 id="4-检测字符串是否相等"><a href="#4-检测字符串是否相等" class="headerlink" title="4.检测字符串是否相等"></a>4.检测字符串是否相等</h4><ol start="30">
<li><p><code>equals</code>方法检测两个字符串是否相等，返回boolean值</p>
<p><code>equalsIgnorCase</code>方法  不区分大小写的检测</p>
<p>如<code>&quot;Hello&quot;.equalsIgnorCase(&quot;hello&quot;);  //返回true</code></p>
</li>
<li><p>一定不能使用== 运算符检测两个字符串是否相等！</p>
<blockquote>
<p>==只能检测两个字符串是否在同一个位置上</p>
</blockquote>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String greeting = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">       <span class="keyword">if</span> (greeting == <span class="string">&quot;Hello&quot;</span>)...</span><br><span class="line">        <span class="comment">// probably true</span></span><br><span class="line">        <span class="keyword">if</span> (greeting.substring(<span class="number">0</span>,<span class="number">3</span>) == <span class="string">&quot;Hel&quot;</span>)...</span><br><span class="line">        <span class="comment">// probably false</span></span><br></pre></td></tr></table></figure>



<h4 id="5-空串与Null"><a href="#5-空串与Null" class="headerlink" title="5.空串与Null"></a>5.空串与Null</h4><ol start="32">
<li><p>空串””是长度为0的字符串</p>
<blockquote>
<p>检测字符串是否为空</p>
<ul>
<li><code> if(str.length() == 0)</code></li>
<li><code>if (str.equals(&quot;&quot;))</code></li>
</ul>
<p>检测字符串是不是null</p>
<ul>
<li><code>if (str == null)</code></li>
</ul>
<blockquote>
<p>有时要检查一个字符串既不是null也不是空串</p>
<p><code> if(str.length() != 0 &amp;&amp; str != null)</code></p>
</blockquote>
</blockquote>
</li>
</ol>
<hr>
<h4 id="6-码点与代码单元"><a href="#6-码点与代码单元" class="headerlink" title="6.码点与代码单元"></a>6.码点与代码单元</h4><hr>
<h4 id="7-StringAPI"><a href="#7-StringAPI" class="headerlink" title="7.StringAPI"></a>7.StringAPI</h4><blockquote>
<p>Java重点String类包含50多种方法，大多数用的频率都很高</p>
<p>每一个API的注释都以类名开始，如java.lang.String，类名后是一个或多个方法的名字，解释和参数描述</p>
<p>（java.lang包名的重要性后面再说）</p>
</blockquote>
<ol start="33">
<li><p>简洁列出常用方法</p>
<ol>
<li><p><code>char charAt(int index)</code></p>
<p>返回指定位置的代码段元，返回指定字符串制定下标的char字符</p>
</li>
<li><p><code>int codePointAt(int index)</code></p>
<p>返回指定位置的码点</p>
</li>
<li><p><code>int offsetByCodePoints(int startIndex, int cpCount)</code></p>
<p>从startIndex码点开始，cpCount个码点后的码点索引</p>
</li>
<li><p><code>int compareTo(String other)</code></p>
<p>按照字典顺序，两个字符串比大小，0下标元素一样就继续往后，如果全部一样返回0，如果字符串在other之前那就返回负数，之后返回一个正数，一般返回的数为第一个不同的字符元素的ASCII码差值</p>
</li>
<li><p><code>IntStream codePoints()</code></p>
<p>*将这个字符串的码点作为一个流返回，调用toArray将它们放在一个数组中</p>
</li>
<li><p><code>new String(int[] codePoints, int offset, int count)</code></p>
<p>用数组中从offset开始的count个码点构造一个新的字符串</p>
</li>
<li><p><code>boolean empty()</code></p>
</li>
<li><p><code>booleam blank()</code></p>
<p>用来判断字符串是否为 空 或 空格 组成，如果为空，返回true</p>
</li>
<li><p><code>boolean equals(Object other)</code></p>
</li>
<li><p><code>boolean equalsIgnoreCase(String other)</code></p>
<p>判断字符串是否相等，可忽略大小写，如果相等返回true</p>
</li>
<li><p><code>bolean startWith(String prefix)</code></p>
</li>
<li><p><code>bolean endsWith(String suffix)</code></p>
<p>如果字符串以prefix开头或以suffix结尾，返回true</p>
</li>
<li><p><code>int indexOf(String str)</code></p>
</li>
<li><p><code>int indexOf(String str, int fromIndex)</code></p>
</li>
<li><p><code>int indexOf(int cp)</code></p>
</li>
<li><p><code>int indexOf(int cp, int fromIndex)</code></p>
<p>返回与字符串str或码点cp匹配的第一个子串开始的位置。从索引0或fromIndex开始。如果不存在str则返回-1</p>
</li>
<li><p><code>int lastIndexof(String str)</code></p>
</li>
<li><p><code>int lastIndexof(String str, int fromIndex)</code></p>
</li>
<li><p><code>int lastIndexof(int cp)</code></p>
</li>
<li><p><code>int lastIndexof(int cp, int fromIndex)</code></p>
<p>返回与字符串str或码点cp匹配的最后一个子串开始的位置。从字符串结尾或fromIndex开始。如果不存在str则返回-1</p>
</li>
<li><p><code>int length()</code></p>
<p>返回字符串代码单元的个数</p>
</li>
<li><p><code>int codePointCount(int startIndex, inr startIndex)</code></p>
<p>返回startIndex，startIndex之间的码点个数</p>
</li>
<li><p><code>String replace(CharSequence oldString, CharSequence newString)</code></p>
<p>返回一个新的字符串，用newString去替换oldString。可以用String或StringBuilder对象作为CharSequence的参数</p>
</li>
<li><p><code>String substring(int beginIndex)</code></p>
</li>
<li><p><code>String substring(int beginIndex, int endIndex)</code></p>
<p>返回一个新的字符串，从beginIndex开始到结尾后或到endIndex</p>
</li>
<li><p><code>String toLowerCase()</code></p>
</li>
<li><p><code>String toUpCase()</code></p>
<p>返回一个新的字符串，将原字符串大写变小写或小写变大写</p>
</li>
<li><p><code>String trim()</code></p>
</li>
<li><p><code>String strip()</code></p>
<p>返回一个新字符串。这个字符串删除原始字符串头部和尾部小于等于U+0020的字符（trim）或者空格（strip）</p>
</li>
<li><p><code>String join(CharSequence delimiter, charSequence... elements)</code></p>
<p>返回一个 新的字符串，用给定的定界符连接所有元素</p>
</li>
<li><p><code>String repeat(int count)</code></p>
<p>返回一个字符串，将当前字符串重复count次</p>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>注意：CharSequence类型的参数，这是一种接口类型，所有字符串都属于这个接口</p>
<p>后面再具体说，现在只需要知道 当看到一个CharSequence形参（parameter）时，完全可以传入String类型的的实参（argument）</p>
</blockquote>
<h4 id="8-构建字符串StringBuilder"><a href="#8-构建字符串StringBuilder" class="headerlink" title="8.构建字符串StringBuilder"></a>8.构建字符串StringBuilder</h4><ol start="34">
<li><blockquote>
<p>有些死后，需要较短的的字符串构建字符串。</p>
<p>比如，按键或者来自文件的单词，这个时候如果字符串拼接效率就会很低，因为每次拼接字符串时都会穿件一个新的String对象，既耗时又费时间</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;首先。构造一个空字符串构建器</span><br><span class="line">StringBuilder builder &#x3D; new StringBuilder();</span><br><span class="line">&#x2F;&#x2F;每次需要添加一部分时就调用apped方法</span><br><span class="line">builder.append(ch); &#x2F;&#x2F;appends a single character</span><br><span class="line">builder.append(str); &#x2F;&#x2F;appends a string</span><br></pre></td></tr></table></figure>

<ul>
<li>StringBuilder类在JAVA5引入，前身是StringBuffer。注意区别，后面再说区别吧</li>
</ul>
</li>
</ol>
<h4 id="9-StringBuilderAPI"><a href="#9-StringBuilderAPI" class="headerlink" title="9.StringBuilderAPI"></a>9.StringBuilderAPI</h4><ol start="35">
<li><p>java.lang.Stringbuilder</p>
<ol>
<li><p><code>StringBuilder()</code></p>
<p>构建一个空的字符串构造器</p>
</li>
<li><p><code>int length()</code></p>
<p>返回构建器或缓冲器*中的代码单元</p>
</li>
<li><p><code>StringBuilder append(String str)</code></p>
</li>
<li><p><code>StringBuilder append(Char c)</code></p>
<p>追加一个字符串或代码单元并返回this</p>
</li>
<li><p><code>StringBuilder appendCodePoint(int cp)</code></p>
<p>追加一个码点，并将其转换为一个或者两个代码单元并返回this</p>
</li>
<li><p><code>void setCharAt(int i , char c)</code></p>
<p>将第i个代码单元设置为c</p>
</li>
<li><p><code>StringBuilder insert(int offset , String str)</code></p>
</li>
<li><p><code>StringBuilder insert(int offset , char c)</code></p>
<p>在第offset位置插入一个字符串str后者代码单元c并返回this</p>
</li>
<li><p><code>StringBuilder delete(int startIndex , int endndex)</code></p>
<p>删除从startIndex到endIndex-1 的代码单元并返回this</p>
</li>
<li><p><code>String toString()</code></p>
<p>返回一个与构建器或缓冲器内容相同的字符串</p>
</li>
</ol>
</li>
</ol>
<h2 id="输入或输出"><a href="#输入或输出" class="headerlink" title="输入或输出"></a>输入或输出</h2><ol start="36">
<li>为了增加后面实例程序趣味性p55</li>
</ol>
<h4 id="读取输入"><a href="#读取输入" class="headerlink" title="读取输入"></a>读取输入</h4><ol start="37">
<li><p>构建Scanner类用Scanner类里的各种方法去读取输入</p>
</li>
<li><p>Scanner类定义在java.util包中需要导包</p>
<blockquote>
<p>当使用的的类不在java.lang基本包中时，要用import指令导入相应的包</p>
</blockquote>
</li>
<li><p>因为输入是可见的，所以Scanner类不适用从控制台读取密码，Java6引入Console类来解决这个问题</p>
</li>
</ol>
<h4 id="ScannerAPI"><a href="#ScannerAPI" class="headerlink" title="ScannerAPI"></a>ScannerAPI</h4><ol start="40">
<li><p>java.util.Scanner</p>
<ol>
<li><code>Scanner(InputStream in)</code></li>
<li>``</li>
<li>``</li>
<li>``</li>
</ol>
</li>
<li><p>java.lang.System</p>
<p>1.<code>static Console console()</code></p>
</li>
<li><p>java.io.Console</p>
<ol>
<li><p>static</p>
</li>
<li><p>``</p>
</li>
</ol>
</li>
</ol>
<h4 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h4><ol start="43">
<li><p><code>System.out.print();</code></p>
</li>
<li><p>也可以用c语言中的格式控制去输出prinf方法</p>
<p><code>System.out.prinf(&quot;%8.2f&quot;,x);</code></p>
<blockquote>
<p>用于printf的各种   转换符   和  标志符   时间日期的转换符</p>
</blockquote>
</li>
</ol>
<h4 id="文件输入与输出"><a href="#文件输入与输出" class="headerlink" title="文件输入与输出"></a>文件输入与输出</h4><ol start="45">
<li><p>要想读取一个文件，仍然需要构建一个Scanner对象，如下所示</p>
<p><code>Scanner in = new Scanner(Path.of(&quot;myfile.txt&quot;), StandardCharsets.UTF_8);</code></p>
<blockquote>
<p>如果文件名中包含反斜杠，要在反斜杠前再加一个额外的反斜杠</p>
<p><code>&quot;C:\\mydirectory\\myfile.txt&quot;</code></p>
</blockquote>
</li>
<li><p>如果想要写入文件，就要构造一个PrintWriter对象</p>
<p><code>Printer out = new PrintWriter(&quot;myfile.txt&quot;,  StandardCharsets.UTF_8) </code></p>
<p>如果文件不存在就创造文件</p>
</li>
<li><p>java.util.Scanner</p>
<ol>
<li>Scanner(Path p , String encoding)</li>
<li>Scanner(String data)</li>
</ol>
</li>
<li><p>java.io.PrinterWriter</p>
<ol>
<li>PrintWriter(String fileName)</li>
</ol>
</li>
<li><p>java.nio.file.Path</p>
<ol>
<li>static Path of(String pathname)</li>
</ol>
</li>
</ol>
<h2 id="控制流程"><a href="#控制流程" class="headerlink" title="控制流程"></a>控制流程</h2><blockquote>
<p>注意看书中每一小节开始的引入的那段话</p>
</blockquote>
<ol start="50">
<li><p>块作用域</p>
<p>再开始深入学习控制流程前，要先了解block块的概念</p>
</li>
<li><p>条件语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if (condition) &#123;</span><br><span class="line">statement1</span><br><span class="line">statement2</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">statement3</span><br><span class="line">statement4</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 在condition为真时执行大括号里的所有语句</span><br><span class="line">&#x2F;&#x2F; 在condition为否时执行此if配对的的else大括号里的所有语句</span><br><span class="line">&#x2F;&#x2F; else总与最近的if组成一组，可以不写else</span><br></pre></td></tr></table></figure></li>
<li><p>循环</p>
<blockquote>
<p>当条件为true时，while循环执行一条语句，也可以是一个语句块</p>
<p><code>while (condition) statement</code></p>
<p>切记，如果初始的condition值就为false，那么while循环一次也不执行</p>
</blockquote>
<p>因为while循环是在执行前先检查条件，因此循环体代码可能一次也不执行</p>
<p>如果需要循环体最少执行一次可以使用do/while循环</p>
<p><code>do &#123;statement...&#125; while (condition)</code></p>
</li>
<li><p>确定循环</p>
<blockquote>
<p>for循环语句是支持迭代的一种通用结构，有一个计数器或类似的变量控制迭代次数，每次迭代后这个变量会更新。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (int i ; i&lt;&#x3D;10 ; i++)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 循环将数字1-10输出一遍</span><br></pre></td></tr></table></figure>

<p>for语句：</p>
<ul>
<li>第一部分：通常是对计数器进行初始化</li>
<li>第二部分：给出每次新一轮循环执行前都要检测的循环条件</li>
<li>第三部分：指定如何更新计数器</li>
</ul>
<blockquote>
<p>后面说Java5新加的 “泛型for循环” 即 for each循环</p>
</blockquote>
</li>
</ol>
<ol start="54">
<li><p>多重选择：switch语句</p>
<blockquote>
<p>在处理多个选项时，使用if/else结构显得有些笨拙，这时Java提供了一个和C/C++完全一样的switch语句</p>
</blockquote>
<p>例如，建立一个包含四个选项的菜单系统</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Scanner in =<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.print(<span class="string">&quot;Select an option (1,2,3,4)&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> choice = in.nextInt();</span><br><span class="line"><span class="keyword">switch</span> (choice)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">	<span class="comment">// bad input</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>switch语句将从与选项值相匹配的case开始执行，直到遇到break语句，或者执行到语句快结束，如果没有一个匹配的选项，有default的话就执行default语句；</p>
<blockquote>
<p>如果没有在case后写break，那么可能触发多个case</p>
<p>判断好哪个case后如果这个case没有写break就会直接执行下一个case</p>
</blockquote>
<blockquote>
<p>case标签可以是：</p>
<pre><code>- 类型为char，byte，short，或int的常量表达式子
- 枚举常量
- 从Java7开始，还可以是字符串字面量
</code></pre>
</blockquote>
</li>
<li><p>中断控制流程的语句</p>
<blockquote>
<p>尽管java的设计者吧goto作为保留字，但实际上并没有打算在语言上使它。</p>
<p>通常，goto语句被认为是一种拙劣的程序设计风格</p>
</blockquote>
<p>带标签的break语句，用于跳出多重循环嵌套的语句。</p>
<p>continue跳过当前循环体的剩余部分，跳到最内层循环的首部</p>
</li>
</ol>
<h2 id="大数"><a href="#大数" class="headerlink" title="大数"></a>大数</h2><ol start="56">
<li><blockquote>
<p>如果基本的整数和浮点数不能够满足需求，那么可以使用java.math包中两个很有用的类：</p>
<p>BigInteger  和  BigDecimal  ， 这两个类可以处理包含任意长度数字序列的数值</p>
<p>BigInteger  类实现任意精度的整数运算</p>
<p>BigDecimal  类实现任意精度的浮点数运算</p>
<p>处理大数的加法乘法要用其自带的方法add，multiply</p>
</blockquote>
</li>
<li><p>BigIntegerAPI</p>
</li>
<li><p>BigDecimalAPI</p>
</li>
</ol>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><blockquote>
<p>数组即储存相同类型值的序列</p>
</blockquote>
<ol start="59">
<li><p>声明数组</p>
<p><code>int[] a;</code>    支出数组类型（数组元素类型紧跟[]）和数组变量名字</p>
<p>这只声明了一个整型数组，并没有将a初始化为一个真正的数组，应该使用new操作符创建数组</p>
<p><code>int[] a = new int[100];</code></p>
<p>这条语句声明并初始化了一个可以存储100个整数的数组。</p>
<blockquote>
<p>数组是一种数据结构，是用来存储同一类型值的集合。</p>
<p>通过一个整形下标（index，或称作索引）可以访问数组中的每一个值</p>
</blockquote>
</li>
<li><p>访问数组元素</p>
<blockquote>
<p>首先，前面创建的数组的下标为从0-99，不是1-100.</p>
</blockquote>
<p>可以使用一个循环去给数组填充元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt; <span class="number">100</span> ; i++)    <span class="comment">// 一般不直接写100，使用array.length取得数组中元素个数</span></span><br><span class="line">&#123;</span><br><span class="line">a[i]=i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>创建一个数字数组后，所有元素都初始化为0</p>
<p>boolean数组元素都初始化为false</p>
<p>对象数组的元素都初始化为一个特殊值null，表示这些元素还未存放任何对象</p>
</blockquote>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/28/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/28/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">نُشر في</span>

              <time title="أُنشأ: 2021-04-28 12:08:25" itemprop="dateCreated datePublished" datetime="2021-04-28T12:08:25+08:00">2021-04-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          المحتويات
        </li>
        <li class="sidebar-nav-overview">
          عام
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">المقالات</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">تطبيق الموقع <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
